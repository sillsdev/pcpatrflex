|-PC-PATR Grammar file for FARSI, Based on FARPatr-2019 but ergative version, changing case features to non-binary May 2019


|- additional templates for Balochi 3/29/19

Let direct                  be  <head case>                                 = direct
Let object                  be  <head case>                                 = objective
Let object_case             be  <head case>                                 = objective
Let generic                 be  <head type generic>                         = +
Let attributive             be  <head type attributive>                     = +
Let definite                be  <head type indefinite>                      = -

|-***********************************************************
|-Feature templates

Let absolutive              be  <head case>                                 = absolutive
Let -absolutive             be  <head case>                                 = {ergative genitive dative}
Let accusative              be  <head case>                                 = accusative
Let -accusative             be  <head case>                                 = {nominative genitive dative}
Let AdjP-final              be  <head type AdjP-final>                      = +
                                <head type AdjP-initial>                    = -
Let AdjP-initial            be  <head type AdjP-initial>                    = +
                                <head type AdjP-final>                      = -
Let AdvP-final              be  <head type AdvP-final>                      = +
                                <head type AdvP-initial>                    = -
Let AdvP-initial            be  <head type AdvP-initial>                    = +
                                <head type AdvP-final>                      = -
Let animate                 be  <head type animate>                         = +
Let animate_object          be  <head object head type animate>             = +
Let animate_subject         be  <head subject head type animate>            = +
Let -animate                be  <head type animate>                         = -
Let -animate_object         be  <head object head type animate>             = -
Let -animate_subject        be  <head subject head type animate>            = -
Let benefactor              be  <head case>                                 = benefactor
Let comma                   be  <head type comma>                           = +
Let completive              be  <head infl aspect completive>               = +
Let compound                be  <head type compound>                        = +
Let -compound               be  <head type compound>                        = -
Let comp_suffix             be  <head type comp_suffix>                     = +
Let conj_suffix             be  <head type conj_suffix>                     = +
                                <head type participle>                      = -
Let conjoins_DP             be  <head type conjoins_DP>                     = +
Let conjoins_IP             be  <head type conjoins_IP>                     = +
Let -conjoins_DP            be  <head type conjoins_DP>                     = -
Let -conjoins_IP            be  <head type conjoins_IP>                     = -
Let continuative            be  <head infl aspect continuative>             = +
Let copular                 be  <head type copular>                         = +
                                <head type transitive>                      = -
Let -copular                be  <head type copular>                         = -
                                <head type transitive>                      = +
Let copular_suffix          be  <head type copular_suffix>                  = +
                                    [copular]
Let CP-final                be  <head type CP-final>                        = +
Let -CP-final               be  <head type CP-final>                        = -
Let CP-initial              be  <head type CP-initial>                      = +
Let -CP-initial             be  <head type CP-initial>                      = -
Let CP-specifier-initial    be  <head type CP-specifier-initial>            = +
Let declarative             be  <head infl mood declarative>                = +
Let ditransitive            be  <head type ditransitive>                    = +
                                <head type transitive>                      = +
Let DP-final                be  <head type DP-final>                        = +
Let -DP-final               be  <head type DP-final>                        = -
Let DP-initial              be  <head type DP-initial>                      = +
Let -DP-initial             be  <head type DP-initial>                      = -
Let DO_contraction          be  <head type DO_contraction>                  = +
Let dual                    be  <head agr number>                           = dual
Let dual_object             be  <head object head agr number>               = dual
Let dual_subject            be  <head subject head agr number>              = dual
Let embedded_subjunctive    be  <embedded infl mood realis>                 = - 
Let ergative                be  <head case>                                 = ergative
Let -ergative               be  <head case>                                 = {absolutive genitive}
Let exclusive               be  <head agr person>                           = first exclusive
Let feminine                be  <head agr gender feminine>                  = +
Let feminine_object         be  <head object head agr gender feminine>      = +
Let feminine_subject        be  <head subject head agr gender feminine>     = +
Let first                   be  <head agr person first>                     = +
                                <head agr person second>                    = !-
                                <head agr person third>                     = -
Let first_exclusive_subject be  <head subject head agr person first>        = +
                                <head subject head agr person second>       = -
Let first_exclusive_object  be  <head object head agr person first>         = +
                                <head object head agr person second>        = -
Let first_inclusive_subject be  <head subject head agr person first>        = +
                                <head subject head agr person second>       = +
Let first_inclusive_object  be  <head object head agr person first>         = +
                                <head object head agr person second>        = +
Let first_object            be  <head object head agr person first>         = +
                                <head object head agr person second>        = -
                                <head object head agr person third>         = -
                                <head type object_agr_suffix>               = +
Let first_subject           be  <head subject head agr person first>        = +
                                <head subject head agr person second>       = -
                                <head subject head agr person third>        = -
Let future                  be  <head infl tense future>                    = +
Let gen_initial             be  <head type gen_initial>                     = +
Let genitive                be  <head case>                                 = genitive
Let genitive-accusative     be  <head case>                                 = {genitive accusative}
Let -genitive               be  <head case>                                 = {nominative accusative}
Let genitive_suffix         be  <head type genitive_suffix>                 = +  
                                [genitive]                                  
Let habitual                be  <head infl aspect habitual>                 = +
Let human                   be  <head type human>                           = +
                                [animate]
Let -human                  be  <head type human>                           = -
Let imperative              be  <head infl mood imperative>                 = +
Let imperfective            be  <head infl aspect perfective>               = -
Let impersonal		    be	<head type impersonal>			    = +
Let inclusive               be  <head agr person second>                    = +
Let incompletive            be  <head infl aspect completive>               = -
Let indefinite              be  <head type indefinite>                      = +
                                <head type relative>                        = -
Let infinitive              be  <head infl finite>                          = -
Let interrogative           be  <head infl mood interrogative>              = +
                                <head type question>                        = +
Let -interrogative          be  <head infl mood interrogative>              = -
                                <head type question>                        = -
Let intransitive            be  <head type transitive>                      = -
Let irrealis                be  <head infl mood realis>                     = -
Let locative                be  <head type locative>                        = +
                                <head type temporal>                        = !-
Let manner                  be  <head type manner>                          = +
Let -manner                 be  <head type manner>                          = -
Let masculine               be  <head agr gender masculine>                 = +
Let masculine_object        be  <head object head agr gender masculine>     = +
Let masculine_subject       be  <head subject head agr gender masculine>    = +
Let modifies_Adj            be  <head type modifies_Adj>                    = +
Let modifies_Adv            be  <head type modifies_Adv temporal>           = +
                                <head type modifies_Adv locative>           = +
                                <head type modifies_Adv manner>             = +
                                <head type modifies_Adv reason>             = +
Let modifies_Adv-reason     be  <head type modifies_Adv reason>             = -
                                <head type modifies_Adv locative>           = +
                                <head type modifies_Adv manner>             = +
                                <head type modifies_Adv temporal>           = +
Let modifies_locative       be  <head type modifies_Adv locative>           = +
Let modifies_manner         be  <head type modifies_Adv manner>             = +
Let modifies_NP             be  <head type modifies_NP>                     = +
Let modifies_NPrep          be  <head type modifies_NPrep>                  = +
Let modifies_PP             be  <head type modifies_PP>                     = +
Let modifies_Q              be  <head type modifies_Q>                      = +
Let modifies_reason         be  <head type modifies_Adv reason>             = +
Let modifies_temporal       be  <head type modifies_Adv temporal>           = +
Let motion                  be  <head type motion>                          = +
Let negative                be  <head infl polarity>                        = -
Let negative_prefix         be  <head type negative_prefix>                 = +  
                                [negative]
Let negative_suffix         be  <head type negative_suffix>                 = +
                                [negative]
Let neuter                  be  <head agr gender neuter>                    = +
Let neuter_object           be  <head object head agr gender neuter>        = +
Let neuter_subject          be  <head subject head agr gender neuter>       = +
Let nominative              be  <head case>                                 = nominative
Let -nominative             be  <head case>                                 = {accusative genitive}
Let oblique                 be  <head case>                                 = oblique
Let participle              be  <head type participle>                      = +
Let partitive               be  <head type partitive>                       = +
Let passive                 be  <head type passive>                         = +
Let -passive                be  <head type passive>                         = -
Let passive.optional        be  <head type passive>                         = {+ -}
Let past                    be  <head infl tense past>                      = +
                                <head infl tense present>                   = -
Let perfective              be  <head infl aspect perfective>               = +
Let plural                  be  <head agr number plural>                    = +
                                <head agr number singular>                  = -
Let plural_object           be  <head object head agr number plural>        = +
                                <head object head agr number singular>      = -
                                <head type object_agr_suffix>               = +  |added 24May19
Let plural_subject          be  <head subject head agr number plural>       = +
                                <head subject head agr number singular>     = -
Let poss_dual               be  <head possessor head agr number dual>       = +
                                <head possessor head agr number singular>   = -
                                <head possessor head agr number plural>     = -
Let poss_exclusive          be  <head possessor head agr person first>      = +
                                <head possessor head agr person second>     = -
                                <head possessor head agr person third>      = -
Let poss_feminine           be  <head possessor head agr gender feminine>   = +
Let poss_first              be    [poss_exclusive]
Let poss_inclusive          be  <head possessor head agr person first>      = +
                                <head possessor head agr person second>     = +
                                <head possessor head agr person third>      = -
Let poss_masculine          be  <head possessor head agr gender masculine>  = +
Let poss_plural             be  <head possessor head agr number plural>     = +
                                <head possessor head agr number singular>   = -
Let poss_second             be  <head possessor head agr person first>      = -
                                <head possessor head agr person second>     = +
                                <head possessor head agr person third>      = -
Let poss_singular           be  <head possessor head agr number plural>     = -
                                <head possessor head agr number singular>   = +
Let poss_third              be  <head possessor head agr person first>      = -
                                <head possessor head agr person second>     = -
                                <head possessor head agr person third>      = +
Let possessed               be  <head type possessed>                       = +
Let potential               be  <head infl aspect potential>                = +
Let PP-final                be  <head type QP-final>                        = +
                                <head type QP-initial>                      = -
Let PP-initial              be  <head type QP-initial>                      = +
                                <head type QP-final>                        = -
Let prefix_Prep             be  <head type prefix_Prep>                     = +
Let present                 be  <head infl tense present>                   = +
                                <head infl tense past>                      = -
Let progressive             be  <head infl aspect progressive>              = +
Let question                be  <head type question>                        = +
Let -question               be  <head type question>                        = -
Let QP-final                be  <head type QP-final>                        = +
                                <head type QP-initial>                      = -
Let QP-initial              be  <head type QP-initial>                      = +
                                <head type QP-final>                        = -
Let quantifier              be  <head type quantifier>                      = +
Let reason                  be  <head type reason>                          = +
Let realis                  be  <head infl mood realis>                     = +
Let reciprocal              be  <head type reciprocal>                      = +
Let reflexive               be  <head type reflexive>                       = +
Let relative                be  <head type relative>                        = +
                                <head type indefinite>                      = -
Let -relative               be  <head type relative>                        = -
                                <head type indefinite>                      = -
Let +root                   be  <head type root>                            = +
Let -root                   be  <head type root>                            = -
Let second                  be  <head agr person second>                    = +
                                <head agr person first>                     = -
                                <head agr person third>                     = -
Let second_object           be  <head object head agr person second>        = +
                                <head object head agr person first>         = -
                                <head object head agr person third>         = -
                                <head type object_agr_suffix>               = +
Let second_subject          be  <head subject head agr person second>       = +
                                <head subject head agr person first>        = -
                                <head subject head agr person third>        = -
Let sentential              be  <head type sentential>                      = +
Let short_infinitive        be  <head infl finite>                          = short
Let singular                be  <head agr number singular>                  = +
                                <head agr number plural>                    = -
Let singular_object         be  <head object head agr number singular>      = +
                                <head object head agr number plural>        = -
                                <head type object_agr_suffix>               = +
Let singular_subject        be  <head subject head agr number singular>     = +
                                <head subject head agr number plural>       = -
Let stative                 be  <head infl aspect stative>                  = +
Let stand-alone             be  <head type stand-alone>                     = +
Let subjunctive             be  <head infl mood subjunctive>                = +
                                <head infl mood realis>                     = -
Let suffix_Pn               be  <head type suffix_Pn>                       = +
Let temporal                be  <head type temporal>                        = +
Let -temporal               be  <head type temporal>                        = -
Let third                   be  <head agr person third>                     = +
                                <head agr person first>                     = -
                                <head agr person second>                    = -
Let third_object            be  <head object head agr person third>         = +
                                <head object head agr person first>         = -
                                <head object head agr person second>        = -
                                <head type object_agr_suffix>               = +
Let third_subject           be  <head subject head agr person third>        = +
                                <head subject head agr person first>        = -
                                <head subject head agr person second>       = -
Let transitive              be  <head type transitive>                      = +
Let transitive.optional     be  <head type transitive>                      = {+ -} | 21Jul03
Let wh                      be  <head type wh>                              = +
Let -wh                     be  <head type wh>                              = -


|-special features for compounding restrictions - these only forced to compound when rootgloss matches. Rules currently allow up to 5 rootglosses.

|-listed in persian alphabetical order
Let compounds_with_افتادن،دادن،رفتن،یافتن be    <head type compounds_with1> = fall.pst
                                                <head type compounds_with2> = give.pst
                                                <head type compounds_with3> = go.pst
                                                <head type compounds_with4> = find.pst
                                                <head type compound> = +
Let compounds_with_افتادن،شدن،کردن be           <head type compounds_with1> = fall.pst
                                                <head type compounds_with2> = become.pst
                                                <head type compounds_with3> = do.pst
                                                <head type compound> = +
Let compounds_with_آمدن be                      <head type compounds_with1> = come.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن be                <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن،بردن،کردن be      <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compounds_with3> = carry.pst
                                                <head type compounds_with4> = do.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن،شدن،کردن be       <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compounds_with3> = become.pst
                                                <head type compounds_with4> = do.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن،رفتن،فرستادن be   <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compounds_with3> = go.pst
                                                <head type compounds_with4> = send.pst
                                                <head type compound> = +
Let compounds_with_اندوختن،یافتن be             <head type compounds_with1> = amass.pst
                                                <head type compounds_with2> = find.pst
                                                <head type compound> = +
Let compounds_with_آوردن be                     <head type compounds_with1> = bring.pst
                                                <head type compound> = +
Let compounds_with_آوردن،دادن be                <head type compounds_with1> = bring.pst
                                                <head type compounds_with2> = give.pst
                                                <head type compound> = +
Let compounds_with_آوردن،دادن،گشتن be           <head type compounds_with1> = bring.pst
                                                <head type compounds_with2> = give.pst
                                                <head type compounds_with3> = turn.pst
                                                <head type compound> = +
Let compounds_with_آوردن،داشتن be               <head type compounds_with1> = آوردن
                                                <head type compounds_with2> = داشتن
                                                <head type compound> = +
Let compounds_with_بخشیدن،دادن،یافتن be         <head type compounds_with1> = بخشیدن
                                                <head type compounds_with2> = دادن
                                                <head type compounds_with3> = یافتن
                                                <head type compound> = +
Let compounds_with_بر‌‌آوردن،زدن،کردن،کشیدن   be  <head type compounds_with1> = بر‌‌آوردن
                                                <head type compounds_with2> = زدن
                                                <head type compounds_with3> = کردن
                                                <head type compounds_with4> = کشیدن
                                                <head type compound> = +
Let compounds_with_پوشیدن،دوختن be              <head type compounds_with1> = پوشیدن
                                                <head type compounds_with2> = دوختن
                                                <head type compound> = +
Let compounds_with_خوردن،خریدن،دادن be          <head type compounds_with1> = خوردن
                                                <head type compounds_with2> = خریدن
                                                <head type compounds_with3> = دادن
                                                <head type compound> = +
Let compounds_with_خواندن be                    <head type compounds_with1> = خواندن
                                                <head type compound> = +
Let compounds_with_دادن  be                     <head type compounds_with1> = دادن
                                                <head type compound> = +
Let compounds_with_دادن،فرا‌‌دادن،سپردن،کردن be <head type compounds_with1> = دادن
                                                <head type compounds_with2> = فرا‌‌دادن
                                                <head type compounds_with3> = سپردن
                                                <head type compounds_with4> = کردن
                                                <head type compound> = +
Let compounds_with_دادن،فرمودن،کردن be          <head type compounds_with1> = دادن
                                                <head type compounds_with2> = فرمودن
                                                <head type compounds_with3> = کردن
                                                <head type compound> = +
Let compounds_with_دادن،کردن be                 <head type compounds_with1> = دادن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_دادن،گرفتن be                <head type compounds_with1> = دادن
                                                <head type compounds_with2> = گرفتن
                                                <head type compound> = +
Let compounds_with_دادن،گفتن be                 <head type compounds_with1> = دادن
                                                <head type compounds_with2> = گفتن
                                                <head type compound> = +
Let compounds_with_دادن،یافتن be                <head type compounds_with1> = دادن
                                                <head type compounds_with2> = یافتن
                                                <head type compound> = +
Let compounds_with_داشتن،کردن be                <head type compounds_with1> = داشتن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_داشتن،شدن،کردن،نمودن be      <head type compounds_with1> = داشتن
                                                <head type compounds_with2> = شدن
                                                <head type compounds_with3> = کردن
                                                <head type compounds_with4> = نمودن
                                                <head type compound> = +
Let compounds_with_داشتن،کردن،نمودن be          <head type compounds_with1> = داشتن
                                                <head type compounds_with2> = کردن
                                                <head type compounds_with3> = نمودن
                                                <head type compound> = +
Let compounds_with_دیدن  be                     <head type compounds_with1> = دیدن
                                                <head type compound> = +
Let compounds_with_رسیدن be                     <head type compounds_with1> = رسیدن
                                                <head type compound> = +
Let compounds_with_ساختن،شدن،کردن be            <head type compounds_with1> = ساختن
                                                <head type compounds_with2> = شدن
                                                <head type compounds_with3> = کردن
                                                <head type compound> = +
Let compounds_with_ساختن،شدن،کردن،گشتن be       <head type compounds_with1> = ساختن
                                                <head type compounds_with2> = شدن
                                                <head type compounds_with3> = کردن
                                                <head type compounds_with4> = گشتن
                                                <head type compound> = +
Let compounds_with_ساختن be                     <head type compounds_with1> = ساختن
                                                <head type compound> = +
Let compounds_with_شدن be                       <head type compounds_with1> = شدن
                                                <head type compound> = +
Let compounds_with_شدن،کردن be                  <head type compounds_with1> = شدن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_شدن،کردن،نمودن be            <head type compounds_with1> = شدن
                                                <head type compounds_with2> = کردن
                                                <head type compounds_with3> = نمودن
                                                <head type compound> = +
Let compounds_with_شمردن،گرفتن،نمودن be         <head type compounds_with1> = شمردن
                                                <head type compounds_with2> = گرفتن
                                                <head type compounds_with3> = نمودن
                                                <head type compound> = +
Let compounds_with_کردن be                      <head type compounds_with1> = کردن
                                                <head type compound> = +
Let compounds_with_کردن،گفتن be                 <head type compounds_with1> = کردن
                                                <head type compounds_with2> = گفتن
                                                <head type compound> = +
Let compounds_with_کردن،شدن be                  <head type compounds_with1> = کردن
                                                <head type compounds_with2> = شدن
                                                <head type compound> = +
Let compounds_with_کردن،نمودن be                <head type compounds_with1> = کردن
                                                <head type compounds_with2> = نمودن
                                                <head type compound> = +
Let compounds_with_گفتن be                      <head type compounds_with1> = گفتن
                                                <head type compound> = +
Let compounds_with_گزیدن be                     <head type compounds_with1> = گزیدن
                                                <head type compound> = +
Let compounds_with_گزیدن،کردن be                <head type compounds_with1> = گزیدن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_یافتن be                     <head type compounds_with1> = یافتن
                                                <head type compound> = +
|-Category changes and defaults

Let Adj                     be  <cat> = !Adj
                                <head type ordinal>             = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type sentential>          = !-
                                <head type DP-initial>          = !-
                                <head type genitive_suffix>     = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head type attributive>         = !-
                                <head case>                     = !direct
                                <head type relative>            = !-
                                <head type comma>               = !-
                                <head type impersonal>          = !- |CB 24Jul06
                                <head type compounds_with2>     = !none
                                <head type compounds_with3>     = !none
                                <head type compounds_with4>     = !none
                                <head type compound>            = !unspecified

Let Adv                     be  <cat> = !Adv
                                <head type wh>            = !-
                                <head case>                     = !direct
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type manner>              = !-
                                <head type comma>               = !-
                                <head type temporal>            = !-
                                <head type locative>            = !-
                
Let Art                     be  <cat> = !Art
                                <head type wh>                  = !-
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let Aux                     be  <cat> = !Aux
                                <head type passive>             = !-
                                <head infl finite>              = !+
                                <head infl tense future>        = !-
                                <head infl mood realis>         = !+
                                <head infl polarity>            = !+
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let C                       be  <cat> = C
                                <head type question>            = !-
                                <head type comma>               = !-

|Mark Conj with - values of features if cannot occur in that position!!
Let Conj                    be  <cat> = !Conj
                                <head type conjoins_DP>         = !+
                                <head type conjoins_IP>         = !+
                                <head type CP-initial>          = !+
                                <head type CP-final>            = !+
                                <head type DP-initial>          = !+
                                <head type DP-final>            = !+ 
                                <head type comma>               = !-

Let Deg                     be  <cat> = Deg
                                <head type DO_contraction>      = !-
                                <head case>                     = !direct
                                <head type modifies_Adj>        = !-
                                <head type modifies_Adv temporal> = !-
                                <head type modifies_Adv locative> = !-
                                <head type modifies_Adv manner> = !-
                                <head type modifies_Adv reason> = !-
                                <head type modifies_NP>         = !-
                                <head type modifies_NPrep>      = !-
                                <head type modifies_PP>         = !-
                                <head type modifies_Q>          = !-
                                <head type quantifier>          = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type CP-final>            = !-
                                <head infl polarity>            = !+
                                <head type compound>            = !-
                                <head type DP-final>            = !-
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type comma>               = !-
                                <head agr number plural>        = !-
                                <head type apposition>          = -  |17Jan03CB
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type gen_initial>         = !-  |7Apr03CB
                                <head type comp_suffix>         = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
| Deg meaning 'all' needs to be marked plural
                                 
Let Dem                 be  <cat> = !Dem
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type DO_contraction>      = !-
                                <head case>                     = !direct
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type comma>               = !-
                                <head type apposition>          = - |17Jan03 CB
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type comp_suffix>         = !-
                                <head type demonstrative>       = + |28Jul03 CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let Excl                    be  <cat> = !Excl
                                <head type comma>               = !-

Let N                       be  <cat> = !N
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head infl finite>              = !+
                                <head type animate>             = !-
                                <head type human>               = !-
                                <head type generic>             = !-
                                <head type wh>                  = -
                                <head type reciprocal>          = !-
                                <head type indefinite>          = !-
                                <head type sentential>          = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type proper>              = !-
                                <head type pronoun>             = !- |set by force_Pn to +, so can't have - w/o default 28Jan03 CB
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type compounds_with2>     = !none
                                <head type compounds_with3>     = !none
                                <head type compounds_with4>     = !none
                                <head type compound>            = !unspecified
                                <head type locative>            = !-    |**
                                <head type apposition>          = -  |17Jan03CB
                                <head type reflexive>           = !- |17Feb03CB
                                <head type case-marked>         = -  |1Apr03CB
                                <head type comp_suffix>         = !-
                                <head type transitive>          = !+ |for compound default case, mark intransitive if needed 17Apr03 CB
                                <head type nonfinalcoordination> = - |15Aug03CB
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                
Let Num                     be  <cat> = Num
                                <head type ordinal>             = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type DO_contraction>      = !-
                                <head agr number singular>      = !-
                                <head agr number plural>        = !+
                                [DP-initial]
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type comma>               = !-
                                <head type apposition>          = -  |17Jan03CB
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type comp_suffix>         = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let ordinal                 be  <cat> = !Adj
                                <head type ordinal>             = +
                                <head type indefinite>          = !-
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
    
Let P                       be  <cat> = !P
                                <head type passive>             = !-
                                <head type wh>                  = -
                                <head type partitive>           = !-
                                <head type stand-alone>         = !-
                                <head type prefix_Prep>         = !-
                                <head type suffix_Pn>           = !-
                                <head case>                     = !direct
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type locative>            = !- |21Apr03CB
				<head type NPrep>		= !-  |22Jul06CB

Let Poss                    be  <cat> = !Poss
                                [genitive]
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let Pron                    be  <cat> = !Pron
                                <head type pronoun>             = +
                                <head type proper>              = -
                                <head type wh>                  = !-
                                <head type animate>             = !+
                                <head infl polarity>            = !+
                                <head type reciprocal>          = !-
                                <head type indefinite>          = !-
                                <head type human>               = !+
                                <head type generic>             = !-
                                <head case>                     = !direct
                                <head type locative>            = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type apposition>          = -  |17Jan03CB
                                <head type reflexive>           = !- |17Feb03CB
                                <head type comp_suffix>         = !-
                                <head type compound>            = -
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
               
Let Q                       be  <cat> = Q
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type comma>               = !-
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type comp_suffix>         = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let V                       be  <cat> = !V
                                <head type passive>             = !-
                                <head type sentential>          = !-
                                <head type copular>             = !-
                                <head type copular_suffix>      = !-
                                <head type motion>              = !-
                                <head type reciprocal>          = !-
                                <head infl finite>              = !+
                                <head infl polarity>            = !+
                                <head type participle>          = !-
                                <head infl mood realis>         = !+
                                <head type conj_suffix>         = !-
                                <head type comma>               = !-
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl tense present>       = !-
                                <head infl tense past>          = !-
                                <head type compounded>          = -
				<head type participle_passive>  = -
				<head rootgloss_V_2>            = none
                                <head type object_agr_suffix>   = !-   |24May19
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                               				
|- Farsi categories in AMPLE

Let AdjB                    be  [Adj]

Let NB                      be  [N]
				<head type NPrep>		= !-  |22Jul06CB

Let PN                      be  <cat> = !N
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head type animate>             = !+
                                <head type generic>             = !-
                                <head type wh>                  = !-
                                <head type reciprocal>          = !-
                                <head type proper>              = +
                                <head type pronoun>             = -
                                <head type human>               = !+
                                <head type indefinite>          = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type relcl>              = !-
                                <head type relative>            = !-
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type locative>            = !- |Feb03CB
                                <head type apposition>          = -  |17Jan03CB
                                <head type comp_suffix>         = !-
                                <head infl finite>              = +
                                <head type compound>            = -
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
  

Let PNP                     be  <cat> = !N
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head type animate>             = !-
                                <head type wh>                  = !-
                                <head type generic>             = !-
                                <head type reciprocal>          = !-
                                <head type proper>              = +
                                <head type pronoun>             = -
                                <head type human>               = !-
                                <head type indefinite>          = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type relcl>              = !-
                                <head type relative>            = !-
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type locative>            = !+ | Feb03CB
                                <head type apposition>          = -  |17Jan03CB
                                <head type comp_suffix>         = !-
                                <head infl finite>              = +
                                <head type compound>            = -
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                
Let Pn                      be  [Pron]
				<head type NPrep>		= !-  |22Jul06CB

Let RefPn                   be  [Pron]  | 31Jan03 RL
                                <head type reflexive>           = +
                                <head type locative>            = !-
				<head type NPrep>		= !-  |22Jul06CB

Let GenericPn               be  [Pron]  | 31Jan03 RL
                                <head type reflexive>           = +
                                <head type generic>             = +
                                <head type locative>            = !-
				<head type NPrep>		= !-  |22Jul06CB
|generic pronouns are marked +reflexive so only need a single constraint to cover both in rules, but also +generic in case a distinction needed  17Feb03 CB

Let Prep                    be    [P]

|NPreps have genitive case and act as if genitive_suffix present to require object with them.  They are locatives for motion verbs
Let NPrep                   be  [N]   | [P]
                                [genitive]
                                [locative]
                                <head type genitive_suffix>     = +
                                <head type apposition>          = -  |17Jan03CB
				<head type NPrep>		= +  |22Jul06CB

Let Cop                     be  <cat> = !V
                                [V]
                                [copular]

Let VActor                  be  [N]

Let VPres                   be  [V]
                                [present]
                                <head type impersonal>          = !- |CB 24Jul06

Let VPast                   be  [V]
                                [past]
                                [completive]
                                <head type impersonal>          = !- |CB 24Jul06

Let VSubj                   be  [V]
                                [irrealis]
                                <head type impersonal>          = !- |CB 24Jul06

Let VPart                   be  [V]
                                <head case>                     = !direct
                                <head type impersonal>          = !- |CB 24Jul06
                            
Let VPerf                   be  [V]
                                [perfective]
                                <head type impersonal>          = !- |CB 24Jul06

Let VProg                   be  [V]
                                [progressive]
                                <head type impersonal>          = !- |CB 24Jul06

Let VInf                    be  [V]
                                <head type impersonal>          = !- |CB 24Jul06
                                
Let Quest                   be  [Adv]
                            
Let QPn                     be  <cat> = Pron
                                [Pron]
                                [wh]

Let Quote                   be  <cat> = Quote

|- override the default category.

Let DO                      be  <cat> = Case
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let makeCase               be  <cat> = Case
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let makeAdv               be  <cat> = Adv
                                <head type wh>            = !-
                                <head case>                     = !direct
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type manner>              = !-
                                <head type comma>               = !-
                                <head type temporal>            = !-
                                <head type locative>            = !-

Let makeAdj               be  <cat> = Adj
                                <head type ordinal>             = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type sentential>          = !-
                                <head type DP-initial>          = !-
                                <head type genitive_suffix>     = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head type attributive>         = !-
                                <head case>                     = !direct
                                <head type relative>            = !-
                                <head type comma>               = !-
                                <head type impersonal>          = !- |CB 24Jul06
                                <head type compounds_with2>     = !none
                                <head type compounds_with3>     = !none
                                <head type compounds_with4>     = !none
                                <head type compound>            = !unspecified

Let force_Dem               be  <cat> = Dem
                                [Dem]

Let force_Pn                be  <cat> = Pron
                                [Pron]

Let force_Prep              be  <cat> = P
                                <head type passive>             = !-
                                <head type wh>                  = -
                                <head type partitive>           = !-
                                <head case>                     = !direct
                                <head type stand-alone>         = !-
                                <head type comma>               = !-
                                <head type locative>            = !- |21Apr03CB

Let force_V                 be  <cat> = V
                                [V]
                                <head type impersonal>          = !- |CB 24Jul06


|- Farsi categories in FLEX *** newly added 2019 to mirror category mapper in PAWS 

Let adj                  be    [Adj]
Let adv                  be    [Adv]
Let aux                  be    [Aux]
Let conn                 be    [Conj]
Let deg                  be    [Deg]
Let dem                  be    [Dem]
Let indf                 be    [Art]
Let interj               be    [Excl]
Let n                    be    [N]
Let n-irreg              be    [N]
Let npl                  be    [N]
                               <head agr number plural>                    = +
                               <head agr number singular>                  = -
Let nprep                be    [NPrep]
Let nprop                be    [PN]
Let num                  be    [Num]
Let post                 be    [P]
Let prep                 be    [P]
Let pro                  be    [Pron]
Let quant                be    [Q]
Let v                    be    [V]
Let vcomp                be    [V]
Let cop                  be    [V]
                               <head type copular>                         = +
Let vphrase              be    <cat> = VP
                               <head type object_agr_suffix>               = !-   |24May19
				


|---------------------------------------------------------------------
|-Phrase structure rules

rule {testing}
S =  DP  

rule {S option start symbol -  final ya na & Quote allowed}
S = {IP / CP} (Conj Deg) (Quote)
    <S head> = <IP head>
    <S head> = <CP head>
    <IP head type root> = +
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = - 
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = start

rule {S option startInitPP symbol with PP initial elements
and final ya na & Quote allowed}
S = InitP {IP / CP} (Conj Deg) (Quote)
    <S head> = <IP head>
    <S head> = <CP head>
    <IP head subject> = <InitP head subject> | pass reflexive info
    <CP head subject> = <InitP head subject> | pass reflexive info
    <IP head type root> = +
    <IP head type pro-drop> = -     | 28May19 CB testing ***
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    <InitP head type PP> = +               | 17Feb03 CB for generic/reflex
    <InitP head type DP> = -               | 17Feb03 CB for generic/reflex
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = startInitPP

rule {S option startInitDP with DP initial elements and final ya na & Quote allowed}
S = InitP IP (Conj Deg) (Quote)
    <S head> = <IP head>
    <IP head subject> = <InitP head subject> | pass reflexive info
    <IP head type root> = +
    <IP head type pro-drop> = -     | 28May19 CB testing ***
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    {<InitP head type relcl> = -  | 03Apr03 CB
    /<InitP head type relcl> = +  |  relcl in InitP only with overt subject
     <IP head type pro-drop> = -
    }
    <InitP head type DP> = +              | 17Feb03 CB for generic/reflex
    <InitP head type PP> = -              | 17Feb03 CB for generic/reflex
| don't split coordination - these replace logical constraints in subject rules that incorrectly eliminated even adverbial InitPs 17Apr03 CB
    <IP head> == ~([subject:[head:[type:[coordination:+]]]] 
                   & [type:[pro-drop:-]])
    <IP head> == ~([object:[head:[type:[coordination:+]]]] 
                   & [type:[pro-drop:+]])
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = startInitDP

rule {S option startCPInitDP with DP initial elements and
final ya na & Quote allowed}
S = InitP CP (Conj Deg) (Quote)
    <S head> = <CP head>
    <CP head subject> = <InitP head subject> | pass reflexive info
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    <InitP head type DP> = +              | 17Feb03 CB for generic/reflex
    <InitP head type PP> = -              | 17Feb03 CB for generic/reflex
    <S rule> = startCPInitDP

rule {S option startInit with nonPP/ DP initial elements and
final ya na & Quote allowed}
S = InitP {IP / CP} (Conj Deg) (Quote)
    <S head> = <IP head>
    <S head> = <CP head>
    <IP head type root> = +
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = startInit

rule {InitP option conj - conjunctions - root or nonroot}
InitP = Conj (Conj_2)
    <InitP head> = <Conj head>
|    <InitP head type comma> = +     |need this to have sentences that start with "w" (and)   | must have comma  ***trying removal of comma requirement 28Jan03 CB 
    <InitP head type initialP> = +      | restrict conjunctions here and in DP 
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = conj

rule {InitP option adv - AdvP - root or nonroot}
InitP = (Conj) AdvP (Conj_2)
    <InitP head> = <AdvP head>
|RL 19Nov02    <InitP head type comma> = +        | must have comma
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <AdvP head type CP-initial> = +    | mark Adv as -CP-initial if not manner but cannot occur clause initial 
    <AdvP head type manner> = -
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = adv

rule {InitP option excl - Exclamation - root or nonroot}
InitP = (Conj) Excl (Conj_2)
    <InitP head> = <Excl head>
    <InitP head type comma> = +        | must have comma
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = excl

|this rule will also include subject DPs with relative clauses and comma in nonroot IPs
rule {InitP option address - DP address or focus/topic - root or nonroot}
InitP = (Conj / Excl) DP
    <InitP head> = <DP head>
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <InitP head type comma> = +        | must have comma
    <InitP head subject> = <DP head reflexive> | pass reflexive info
    <Conj head type CP-initial> = +
    <DP head type coordination> = -       | not a DP coordination construction
    <DP head type nonfinalcoordination> = -
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    {<DP head case> = nominative
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head case_for_position> = direct  | for apposition 
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = +          | 17Feb03 CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <InitP rule> = address

| RL 28Mar03 add this rule
rule {InitP option address2 - DP address or focus/topic - root or nonroot}
InitP = Conj Excl DP
    <InitP head> = <DP head>
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <InitP head type comma> = +        | must have comma
    <InitP head subject> = <DP head reflexive> | pass reflexive info
    <Conj head type CP-initial> = +
    <DP head type coordination> = -       | not a DP coordination construction
    <DP head type nonfinalcoordination> = -
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head case_for_position> = direct  | for apposition 22Jan03 CB
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = +          | 17Feb03 CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <InitP rule> = address2

| RL 10Dec02
rule {InitP option address_conjoined - DP address or focus/topic - root or nonroot}
InitP = Excl DP Conj (Excl_2) DP_2 | e.g. Acts 13:16 <<ay mrdan asraYyly w ay Gyryhwdyan Xdatrs, KwS fra^^dhyd!
    <InitP head> = <DP_2 head>
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <InitP head type comma> = +        | must have comma
    <InitP head subject> = <DP head reflexive> | pass reflexive info
    <InitP head subject> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = -       | not a DP coordination construction
    <DP head type nonfinalcoordination> = -
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head case_for_position> = direct  | adjective/apposition 17Apr03 CB
    <DP_2 head case_for_position> = direct  | adjective/apposition 17Apr03 CB
    <DP_2 head type coordination> = -       | not a DP_2 coordination construction
    <DP_2 head type nonfinalcoordination> = -
    {<DP_2 head case> = direct
     <DP_2 head type modifier-final> = -
    /<DP_2 head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP_2 head case> = genitive
    }
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = +          | 17Feb03 CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <InitP rule> = address_conjoined

rule {InitP option manner PP - root only}
InitP = (Conj / Adv) PP (Conj_2)
    <InitP head> = <PP head>
    <InitP head type comma> = +        | must have comma
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <PP head type manner> = +
    <PP head type temporal> = -
    <PP head type locative> = -
|    <PP head type passive> = -          | this may not work, remove if passive P can be here
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = mannerPP

rule {InitP option tempPP - temporal PP - root only}
InitP = (Conj / Adv) PP (Conj_2)
    <InitP head> = <PP head>
    <InitP head type comma> = +        | must have comma
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <PP head type temporal> = +
    <PP head type manner> = -
    <PP head type locative> = -
    <PP head type passive> = -          | this may not work, remove if passive P can be here
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = tempPP

rule {InitP option locPP - locative PP - comma not required - root only}
InitP = (Conj (Conj_1) / Adv) PP (Conj_2)
    <InitP head> = <PP head>
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <Adv head type temporal> = -
    <PP head type manner> = -
    <PP head type locative> = +
    <PP head type temporal> = -
    <PP head type passive> = -          
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_1 head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = locPP

| separated off from locPP rule to avoid possibility of stranded Conj **19Jul06 CB  | 23Jan03 RL removed passive restriction in locPP above E.g. az nsl ayn mrd 
rule {InitP option passivePP - comma not required - root only}
InitP = (Conj (Conj_1) / Adv) PP
    <InitP head> = <PP head>
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <Adv head type temporal> = -
    <PP head type manner> = -
    <PP head type temporal> = -
    <PP head type passive> = +          | 23Jan03 RL removed passive restriction. E.g. az nsl ayn mrd  |this may not work, remove if passive P can be here
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_1 head type CP-initial> = + 
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = passivePP

rule {InitP option CP - adverbial CP - root only}
InitP = (Conj/InitP_2) CP (Conj_2) | RL 07Dec02 allow another InitP inside this InitP e.g.: "bradran, aKr pnd w andrzy bray mrdm daryd, bKwyyd."
    <InitP head> = <CP head>
    <InitP head type comma> = +        | must have comma
    <InitP head type root> = +
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <InitP_2 head type comma> = +        | must have comma | RL 07Dec02 added
    <InitP head subject> = <InitP_2 head subject> | pass reflexive info
|    <CP head type root> = -           | removed 02Dec02 CB
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = CP

|-***********************************************************
rule {CP option 1 - no fronting, root or non-root}
CP = C'
    <CP head> = <C' head>
    <CP rule> = 1

|-**********************************************************
rule {C' option 1c - head-initial, question, root}
C' = C IP
    <C' head> = <IP head>
    <C' head type question> = <C head type question> | amended 02Dec02 CB
    <C' head type root> = <C head type root>
    <C' head type root> = +
    <C' head type question> = +
    <C head type comma> = -
    <C head type CP-initial> = +
    <C' rule> = 1c

rule {C' option 1creason - head-initial, reason, root}
C' = C IP
    <C' head> = <IP head>
    <C' head type question> = <C head type question> | amended 02Dec02 CB
    <C' head type reason> = <C head type reason> | amended 02Dec02 CB
    <C' head type root> = +
    <C' head type question> = -
    <C head type reason> = +
    <C head type comma> = -
    <C head type CP-initial> = +
    <C' rule> = 1creason

rule {C' option 2c - head-initial, question, non-root}
C' = (C_1) C_2 IP
    <C' head> = <IP head>
    <C' head type question> = <C_2 head type question> |amended 02Dec02 CB
    <C' head type root> = <C_2 head type root>
    <C' head type root> = -
    <C_1 head type comma> = -
    <C_2 head type comma> = -
    <C_1 head type question> = -
    <C_2 head type question> = +
    <C_1 head type CP-initial> = +
    <C_2 head type CP-initial> = +
    <C' rule> = 2c

rule {C' option 2j - head-initial, non-question, non-root}
C' = C IP
    <C' head> = <IP head>
    <C' head type question> = <C head type question>   | RL 13Feb02 if IP has a comma and C doesn't they can't unify for type.
    <C' head type root> = -
    <C' head type question> = -
    <C head type comma> = -
    <C head type CP-initial> = +
    <C embedded> = <IP head embedded>    | pass subcategorization down
    <C' rule> = 2j

|-***********************************************************
rule {IP option 0 - conjoined IPs}
IP = IP_1 Conj IP_2
    <IP head> = <IP_1 head>
    <IP conjoined> = +                | limit recursion
    <IP_1 conjoined> = -
    <IP_2 head type pro-drop> = -
    <IP_1 head type root> = <IP_2 head type root>
    <IP_1 head infl mood realis> = <IP_2 head infl mood realis> | 15Jul03 CB
    <Conj head type conjoins_IP> = +
    <IP head type comma> <= <IP_2 head type comma>  | comma placement for InitP
    <IP_1 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP_2 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP rule> = 0

rule {IP option 0a-DP - missing final verb IPs}
IP = IP_1 Conj DP
    <IP head> = <IP_1 head>
    <IP head subject> = <DP head reflexive> | pass reflexive info
    {<DP head case> = direct
     <DP head type modifier-final> = -
     <DP head type case-marked> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
     <DP head type case-marked> = -
    /<DP head case> = objective
     <DP head type case-marked> = +
    }
    <DP head type coordination> = -
    <IP head type conjoined> <= +   | mark for checking compounding constraints (special case with relcl2+kh and 5c) 20Oct03 CB
    <IP head type final-conjunct compounds_with1> = <DP head type compounds_with1>
    <IP head type final-conjunct compounds_with2> = <DP head type compounds_with2>
    <IP head type final-conjunct compounds_with3> = <DP head type compounds_with3>
    <IP head type final-conjunct compounds_with4> = <DP head type compounds_with4>
    <IP head type comma> <= <DP head type comma>  | comma placement for InitP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <Conj> == ~[gloss:یعنی]
    <IP rule> = 0a-DP

| for ygny type apposition/coordination/relativization, added 24Mar03 CB
rule {IP option 0a-ygny - "ygny"-type apposition}
IP = IP_1 Conj DP
    <IP head> = <IP_1 head>
    <IP_1 head type comma> = +         | must have comma when at end
    <IP head subject> = <DP head reflexive> | pass reflexive info
    {<DP head case> = direct
     <DP head type modifier-final> = -
     <DP head type case-marked> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
     <DP head type case-marked> = -
    /<DP head case? = objective
     <DP head type case-marked> = +
    }
    <Conj gloss> = یعنی
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP rule> = Oa-ygny
   
| for ygny type apposition/coordination/relativization, added 24Mar03 CB
rule {IP option 0a-ygnyPP - "ygny"-type apposition with PP}
IP = IP_1 Conj PP
    <IP head> = <IP_1 head>
    <IP_1 head type comma> = +         | must have comma when at end
    <Conj gloss> = یعنی
    <IP head subject> = <PP head reflexive> | pass reflexive info
    <PP head type sentential> = -
    <IP rule> = Oa-ygnyPP
   
rule {IP option 0a-AdjP - missing final verb IPs}
IP = IP_1 Conj AdjP
    <IP head> = <IP_1 head>
    <AdjP head case> = direct
    <IP head type comma> <= <AdjP head type comma>  | comma placement for InitP
    <IP rule> = 0a-AdjP

rule {IP option 0b - 2 IPs, initial IP in participle form}
IP = IP_1 IP_2
    <IP head> = <IP_2 head>
    <IP conjoined> = +                | limit recursion
    <IP_1 conjoined> = -
    <IP_1 head type conj_suffix> = +  | allow the participle suffix to serve as a conjunction.
    <IP_1 head type comma> = +        | 13Mar03 CB added per Ron
    <IP_1 head type root> = <IP_2 head type root>
    <IP_1 head subject> = <IP_2 head subject>
    <IP_2 head type auxiliary> = -   | RL 10Feb03 No auxiliaries. E.g. we don't want this sentence from Acts 13:26 to be handled here 'ayn pyam njat bray ma frstadh Sdh ast.'
    <IP_1 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP_2 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP rule> = 0b

|*****split rule for impersonalV and then non-past and pst transitive*****
rule {IP option 2cImpersonalV - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
    <I' head subject> = <DP>
    <I' head type impersonal> = +       | impersonal verbs do not agree **24Jul06 CB
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    {<DP head case> = oblique
     <DP head type modifier-final> = -
     <DP head agr person third> = +
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cImpersonalV
    
rule {IP option 2cINon-ImpersonalVNonPast - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <I' head type impersonal> = -
     <I' head infl tense past> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalVNonPast

rule {IP option 2cINon-ImpersonalV-PastIntransitive - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <I' head type impersonal> = -
     <I' head infl tense past> = +
     <I' head type transitive> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP rule> = 2cNon-ImpersonalV-PastIntransitive

rule {IP option 2cINon-ImpersonalV-PastTransitive - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <I' head type impersonal> = -
     <I' head infl tense past> = +
     <I' head type transitive> = +
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    {<DP head case> = oblique
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalV-PastTransitive

rule {IP option 2cII - subject initial, pro-drop, root clause}
IP = I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = +
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [object:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ~([infl:[tense:[past:+]]] & [type:[transitive:+]]) | past transitive must have overt subject CB 30May19
    <IP rule> = 2cII

|*****split rule for impersonalV and then non-past and past transitive*****
rule {IP option 2cImpersonalVnonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
    <I' head subject> = <DP>
    <I' head type impersonal> = +       | impersonal verbs do not agree **24Jul06 CB
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    {<DP head case> = oblique
     <DP head type modifier-final> = -
     <DP head agr person third> = +
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cImpersonalVnonroot
    
rule {IP option 2cNon-ImpersonalVNonPastnonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <I' head type impersonal> = -
     <I' head infl tense past> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalVNonPastnonroot

rule {IP option 2cNon-ImpersonalV-PastIntransitivenonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <I' head type impersonal> = -
     <I' head infl tense past> = +
    <I' head type transitive> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP rule> = 2cNon-ImpersonalV-PastIntransitivenonroot

rule {IP option 2cNon-ImpersonalV-PastTransitivenonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <I' head type impersonal> = -
     <I' head infl tense past> = +
    <I' head type transitive> = +
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    {<DP head case> = oblique
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalVPastTransitivenonroot


rule {IP option 2cIInonroot - subject initial, pro-drop, nonroot clauses}
IP = (InitP) I'
    <IP head> = <I' head>
    <IP head type root> = -
    <I' head subject> = <InitP head subject> | pass reflexive info
    <InitP head type root> = -
    <IP head type pro-drop> = +
    <IP head type initialP> <= <InitP head type initialP> 
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [object:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP rule> = 2cIInonroot

|-***********************************************************
rule {I' option 0 - conjoined I's}
I' = I'_1 Conj I'_2
    <I' head> = <I'_1 head>
    <I' conjoined> = +                | limit recursion
    <I'_1 conjoined> = -
    <I'_1 head subject> = <I'_2 head subject>
    <I'_1 head infl mood realis> = <I'_2 head infl mood realis> | 15Jul03 CB
    {
    <I'_1 head type auxiliary> = +      | one of the two verbs has an auxiliary or both do.
    <I'_2 head type auxiliary> = - /
    <I'_1 head type auxiliary> = -
    <I'_2 head type auxiliary> = + /
    <I'_1 head type auxiliary> = +
    <I'_2 head type auxiliary> = +
    }
    <Conj head type conjoins_IP> = +
    <I' rule> = 0

|not for Sdn
rule {I' option 1 - no auxiliaries}
I' = VP
    <I' head> = <VP head>
    <I' head type auxiliary> = -
    {<I' head type participle> = -     | the participle is only allowed when followed by an Aux 03Apr03 CB
    /<I' head type participle> = +     | OR when the verb is passive
     <I' head type passive> = +
    /<I' head type participle> = +     | OR when the verb has past endings
     <I' head infl tense past> = +     | 17Jul03 CB
     <I' head type passive> = -
    } 
    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <VP head> == ~[rootgloss:become.pst]
    <VP head> == ~[rootgloss_V_2: become.pst]            | 12-APR-04
    <I' rule> = 1

rule {I' option 1Sdn - no auxiliaries}
I' = VP
    <I' head> = <VP head>
    <I' head type auxiliary> = -
    {<VP head rootgloss> = become.pst
    /<VP head rootgloss_V_2> = become.pst               | 12-APR-04
    }
    {<I' head type participle> = -     | the participle is only allowed when followed by an Aux 03Apr03 CB
    / <VP head type compound> = +       | OR when Sdn is compound 17Apr03 CB
     <I' head type participle> = +
    } 
    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <I' rule> = 1Sdn

rule {I' option 3 - Aux final, required}
I' = VP Aux
    <I' head> = <VP head>
    <I' head type auxiliary> = +
    <I' head subject head agr> = <Aux head subject head agr>
    <VP head type comma> = -
    <VP head type participle> = +          | all auxiliaries require the verb to be in participle form (not future--different rule V F)
    |<I' head infl> = <Aux head infl>  | RL 13Feb02
    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <I' rule> = 3

|-***********************************************************
rule {VP option 0adj - adjoined CP}
VP = VP_1 CP
    <VP head> = <VP_1 head>
    <CP head type root> = -
    <CP head type relcl> = -          | 21Nov03 CB
    <VP_1 head type sentential> = -
    <VP head type comma> <= <CP head type comma>  | 04Apr03 CB
    <VP rule> = 0adj

rule {VP option 0conj - conjoined VPs}
VP = VP_1 Conj VP_2
    <VP head rootgloss> = <VP_1 head rootgloss>     | for compounding constraints 12-APR-04
    <VP head rootgloss_V_2> <= <VP_2 head rootgloss> | for Sdn Aux constraints
    <VP head subject> = <VP_1 head subject> | CB 16Jan03
    <VP_1 head subject> = <VP_2 head subject>  | subjects agree
    <VP head type participle> = <VP_1 head type participle> | CB 16Jan03
    <VP_1 head type participle> = <VP_2 head type participle>
    <VP head type relcl> = <VP_1 head type relcl> | CB 10Dec03
    <VP_1 head type relcl> = <VP_2 head type relcl>
    <VP head infl> = <VP_1 head infl> | CB 16Jan03
    <VP head type no_intervening> = -   | for compounding constraint 15Apr03 CB
    <VP conjoined> = +                | limit recursion
    <VP_1 conjoined> = -
    <Conj head type conjoins_IP> = +
|    <VP_2 head infl mood realis> = +  | for subjunctive, use embedded rule  | removed  27Jan03
    <VP_2 head infl mood realis> = <VP_1 head infl mood realis>     | added instead 27Jan03 CB
    <VP_1 head type conj_suffix> = -                | 09-APR-04 
    <VP head type conj_suffix> = <VP_2 head type conj_suffix> | pass to IP 0b
    <VP head type comma> <= <VP_2 head type comma>  | 04Apr03 CB
    <VP rule> = 0conj

rule {VP option 1Adv - adjoined AdvP}
VP = AdvP VP_1
    <VP head> = <VP_1 head>
    <AdvP head type comma> = -
|    <AdvP head type manner> = +         | removed this restriction and eliminated AdvP w/in VP 20Feb03 CB
    {<AdvP head infl polarity> = +	 | either the adverb is not negative - 07-APR-04
    /<AdvP head infl polarity> = -	 | or the adverb is negative
     <VP_1 head infl polarity> = -	 | and the verb must be negative
    /<AdvP head infl polarity> = -	 | or the adverb is negative
     <VP_1 head infl polarity> = +	 | and the verb is subjuctive
     <VP_1 head infl mood realis> = -
    }
    <VP head type no_intervening> <= -   | for compounding constraint
    <VP rule> = 1Adv

|VP_1 already compound or intervening material
rule {VP option 1PPno - adjoined PP, no need for compound test}
VP = PP VP_1
    <VP head> = <VP_1 head>
    <VP head subject> = <PP head reflexive> | pass reflexive info
    {<PP head type comma> = -
    /<PP head type comma> = +		 | PP may have comma if object contains apposition 07-APR-04
     <PP head object head type apposition> = +
    }
    <PP head type sentential> = -        | added 31Mar03 CB
    {<VP_1 head type no_intervening> = -  | for compounding constraint
    /<VP_1 head type no_intervening> = +
     <VP_1 head type compounded> = +      | or already compounded
    }
    <VP rule> = 1PPno

rule {VP option 1PP - adjoined PP, possible compound situation}
VP = PP VP_1
    <VP head> = <VP_1 head>
    <VP head subject> = <PP head reflexive> | pass reflexive info
      {<PP head type comma> = -
    /<PP head type comma> = +		 | PP may have comma if object contains apposition 07-APR-04
     <PP head object head type apposition> = +
    }
    <PP head type sentential> = -        | added 31Mar03 CB
    <VP_1 head type no_intervening> = +
    <VP_1 head type compounded> = -      | not already compounded
    <VP head type no_intervening> <= -   | for compounding constraint
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 1PP

rule {VP option 2a - V initial/final, intransitive or copular}
VP = V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    {<V head type transitive> = -
    /<V head type transitive> = +  | or transitive within a relative clause
     <VP head type relcl> = +    | 20Nov03 CB
    }
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type passive> = -
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 2a

rule {VP option 3b - V final, motion intransitive with locative}
VP = DP V 
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head case> = genitive    | headed by NPrep
    <DP head type genitive_suffix> = +
    <DP head type locative> = +
    <DP head type coordination> = - | don't allow coordinate DPs 12Feb03 CB
    <DP head type nonfinalcoordination> = -
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type transitive> = -
    <V head type copular> = -
|    <V head type motion> = +
    <V head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 3b

|added 30May19
rule {VP option 3bPP - V final, motion intransitive with locative PP or AdvP}
VP = {PP / AdvP} V 
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <PP head type locative> = +
    <AdvP head type locative> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type transitive> = -
    <V head type copular> = -
    <V head type motion> = +
    <V head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 3bPP

rule {VP option 4badj - V final, copular w/ adj, not passive}
VP = AdjP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <AdjP head type comma> = -
    <AdjP head case> = direct
    <AdjP head type attributive> = -   |CB 9May19 Predicate adjectives not attributive
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <AdjP head type> == ~[compound:+]     | AdjPs which are marked compound, must compound
    <VP rule> = 4badj

|rule added 19Nov03 CB 
rule {VP option 4bPcop_sfx - V final, copular_suffix w/ P, not passive}
VP = P V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular_suffix> = +
    <V head type compounded> = -      | 06-APR-04 CB to eliminate P [N V]-copsfx
    <V head case> = direct    | case for pronoun copular_suffix attached to
    <P head type comma> = -
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 4bPcop_sfx

rule {VP option 4badjPP - V final, copular w/ adj then PP, not passive}
VP = AdjP PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <V head subject> = <PP head reflexive>  | pass reflexive info
    <PP head type comma> = -
    <AdjP head type comma> = -
    <AdjP head case> = direct
    <AdjP head type attributive> = -   |CB 9May19 Predicate adjectives not attributive
    <PP head type sentential> = -
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 4badjPP

rule {VP option 4bnom - V final, copular with predicate nominative, not passive}
VP = DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <V head type copular_suffix> = -   | copular_suffix use 4bnomCop_sfx for correct case
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head subject> = <DP head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head case> = genitive		
     <DP head type modifier-final> = +
    }
    <VP head type passive> = -
    <V head object> = <DP>   | for constraint on negative agreement, etc.
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head object head participle> = none   | to force participle to be w/ V or Aux 12-APR-04
    <VP head object head possessor head participle> = none   | to force participle to be w/ V or Aux 12-APR-04
    <VP head> == [rootgloss:^1] -> 
                  ~([object:[head:[type:[modifier-final:-]]]] &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 4bnom

| split off 13-APR-04
rule {VP option 4bnomCop_sfx - copular_suffix with predicate nominative (GEN)}
VP = DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <V head type copular_suffix> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head type comma> = -
    <DP head type apposition> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = genitive
    <V head object> = <DP>   | for constraint on negative agreement, etc.
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head object head participle> = none   | to force participle to be w/ V or Aux 12-APR-04
    <VP head object head possessor head participle> = none   | to force participle to be w/ V or Aux 12-APR-04
    <VP head> == [rootgloss:^1] -> 
                  ~([object:[head:[type:[modifier-final:-]]]] &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 4bnomCop_sfx

rule {VP option 4bnomNPrep - V final, copular with NPrep and predicate nominative, not passive}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <V head type copular_suffix> = -   | copular_suffix use 4bnonNPrepCop_sfx for correct case
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head case_for_position> = genitive
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    <VP head type passive> = -
    <V head object> = <DP>   | for constraint on negative agreement, etc.
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~([object:[head:[type:[modifier-final:-]]]] &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 4bnomNPrep

| split off 13-APR-04
rule {VP option 4bnomNPrepCop_sfx - copular_suffix with NPrep and predicate nominative (GEN)}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <V head type copular_suffix> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive>  | pass reflexive info
    <DP head type comma> = -
    <DP head type apposition> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = genitive
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head case_for_position> = genitive
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    <VP head type passive> = -
    <V head object> = <DP>   | for constraint on negative agreement, etc.
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~([object:[head:[type:[modifier-final:-]]]] &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 4bnomNPrep

rule {VP option 4bNPrep - V final, copular with NPrep, not passive}
VP = DP_1 V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
|    <V head type copular_suffix> = -   | RL 9Feb02 need copular suffix for sentences like "kojast?"
    <DP_1 head participle> = none       | to force participle to be w/ V or Aux 12-APR-04
    <DP_1 head possessor head participle> = none       | to force participle to be w/ V or Aux 12-APR-04
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head subject> = <DP_1 head reflexive>  | pass reflexive info
    <DP_1 head type apposition> = -
    <DP_1 head case_for_position> = genitive
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP_1 head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <VP rule> = 4bnomNPrep

|optional Adv added **19Jul06 CB
|*****split rule for past and then generic and definite*****
rule {VP option 5cPast - V final, transitive}
VP = DP (Adv) V
    <VP head> = <V head>
    <VP head type pro-drop> = -     | subject must be overt
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +  
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = +
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
     <DP head agr person third> = +  
    /<DP head case> = genitive
     <DP head type modifier-final> = +
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <DP head type nonfinalcoordination> = -
    <V head type object_agr_suffix> = +   |CB 24May19   must have object agreement
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relative:[conjoined:+]]]] ) &
                   (( [object:[head:[relative:[compounds_with1:^1]]]]
                    / [object:[head:[relative:[compounds_with2:^1]]]])
                    /([object:[head:[relative:[compounds_with3:^1]]]]
                    / [object:[head:[relative:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 5cPast

rule {VP option 5cNonPastGeneric - V final, transitive}
VP = DP (Adv) V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = -
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = +       | 30May19
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct         | 17Feb03 CB
     <DP head type modifier-final> = -
     <DP head agr person third> = +
    /<DP head case> = genitive
     <DP head type modifier-final> = +
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relative:[conjoined:+]]]] ) &
                   (( [object:[head:[relative:[compounds_with1:^1]]]]
                    / [object:[head:[relative:[compounds_with2:^1]]]])
                    /([object:[head:[relative:[compounds_with3:^1]]]]
                    / [object:[head:[relative:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 5cNonPastGeneric

rule {VP option 5cNonPastNonGenericIndefinite - V final, transitive}
VP = DP (Adv) V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = -
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = -       | 30May19
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head type indefinite> = +
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
     <DP head agr person third> = +
    /<DP head case> = genitive
     <DP head type modifier-final> = +
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relative:[conjoined:+]]]] ) &
                   (( [object:[head:[relative:[compounds_with1:^1]]]]
                    / [object:[head:[relative:[compounds_with2:^1]]]])
                    /([object:[head:[relative:[compounds_with3:^1]]]]
                    / [object:[head:[relative:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 5cNonPastNonGenericIndefinite

rule {VP option 5cNonPastNonGenericDefinite - V final, transitive}
VP = DP (Adv) V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = -
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = -      | 30May19
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head type indefinite> = -
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
    {<DP head case> = oblique          | 17Feb03 CB
     <DP head type modifier-final> = -
     <DP head agr person third> = +
    /<DP head case> = genitive
     <DP head type modifier-final> = +
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relative:[conjoined:+]]]] ) &
                   (( [object:[head:[relative:[compounds_with1:^1]]]]
                    / [object:[head:[relative:[compounds_with2:^1]]]])
                    /([object:[head:[relative:[compounds_with3:^1]]]]
                    / [object:[head:[relative:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 5cNonPastNonGenericDefinite

|********for now, all ditransitives below have objective case IO and direct case DO, no obj agreement, until there's time to split the rules ********
rule {VP option 6cI - V final, DP initial and ditransitive with NPrep}
VP = DP DP_1 V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    <DP_1 head type comma> = - 
    <DP_1 head type apposition> = -   | 27Jan03 CB
    <DP_1 head case_for_position genitive> = +
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP_1 head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 6cI

rule {VP option 6cI+PP - V final, DP initial and ditransitive with NPrep and PP_1}
VP = DP PP_1 DP_1 V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP_1 head type comma> = -
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -   | 27Jan03 CB
    <DP_1 head case_for_position> = genitive
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <PP_1 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP_1 head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 6cI+PP

rule {VP option 6cI+2PP - V final, DP initial and ditransitive with NPrep + two PPs}
VP = DP PP_1 PP_2 DP_1 V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_2 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP_1 head type comma> = -
    <PP_2 head type comma> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -   | 27Jan03 CB
    <DP_1 head case_for_position> = genitive
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <PP_1 head type sentential> = -
    <PP_2 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP_1 head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 6cI+2PP

rule {VP option 6cIPP - V final, DP initial and ditransitive with PP}
VP = DP PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIPP

|***added 30May19 CB  For Object2&3 ***
rule {VP option 6cIDP - V final, PP initial and ditransitive with DP}
VP = PP DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIDP

rule {VP option 6cIPP_1 - V final, DP initial and ditransitive with PP and PP_1}
VP = DP PP_1 PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIPP_1

rule {VP option 6cIPP_2 - V final, DP initial and ditransitive with PP & PP_1 & PP_2}
VP = DP PP_1 PP_2 PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_2 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
    <PP_2 head type comma> = -
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <PP_2 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIPP_2

|rule added 31May19 for pn (1st/2nd) Object Case #3 *****
rule {VP option 6cIIDP - V final, DP_1 IO (not NPrep) and DP object}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = objective
    <DP_1 head type genitive_suffix> = =
    <DP_1 head type locative> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 6cIIDP


rule {VP option 6cII - V final, NPrep and DP}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 6cII

rule {VP option 6cIIPP_3 - V final, NPrep and DP, PP final}
VP = DP_1 DP PP_3 V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_3 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP_3 head type comma> = -
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    <PP_3 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP_3 head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIIPP_3

rule {VP option 6cIIPP_4 - V final, NPrep and DP, 2 PPs final)}
VP = DP_1 DP PP_4 PP_3 V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_3 head reflexive> | pass reflexive info
    <V head subject> = <PP_4 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = یعنی    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP_3 head type comma> = -
    <PP_4 head type comma> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct          | 17Feb03 CB
     <DP head type modifier-final> = -
    /<DP head case> = genitive
     <DP head type modifier-final> = +
    }
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = genitive
    <DP_1 head type genitive_suffix> = +
    <DP_1 head type locative> = +
    <PP_3 head type sentential> = -
    <PP_4 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP_3 head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIIPP_4

|********for now, all ditransitives above have objective case IO?? and direct case DO, and no object agreement, until there's time to split them ********

| 8a and 8aQ separated 06-APR-04 to account for embedded questions with kh Aya where the main verb requires embedded_subjunctive, but not in questions
rule {VP option 8a - V initial, sentential complement - non question}
VP = V {IP / CP}
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type comma> = -
    <IP head type root> = -
    <CP head type root> = -
    <CP head type question> = -
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V embedded> = <IP head embedded>     | pass down and check on verb
    <V embedded> = <CP head embedded>     | pass down and check on verb
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type sentential> = +
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <VP head type comma> <= <IP head type comma>
    <VP head type comma> <= <CP head type comma>
    <VP rule> = 8a

rule {VP option 8aQ - V initial, question complement}
VP = V CP
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type comma> = -
    <CP head type root> = -
    <CP head type question> = +
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type sentential> = +
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <VP head type comma> <= <CP head type comma>
    <VP rule> = 8aQ

| added 07-APR-04 CB for mmkn ast yxyy hman msyx baSd.
rule {VP option 8adj - V final, copular w/ adj, plus sentential}
VP = AdjP V IP
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <AdjP head type comma> = -
    <AdjP head case> = direct
    <V head infl finite> = +        | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <IP head type root> = -
    <AdjP embedded> = <IP head embedded>     | pass down and check on verb, sentential & embedded from Adj
    <AdjP head type sentential> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = +            | don't allow short or regular infinitive at end of verb phrase
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <VP head type comma> <= <IP head type comma>
    <AdjP head type> == ~[compound:+]     | AdjPs which are marked compound, must compound
    <VP rule> = 8adj

rule {VP option 9passI - V participle, passive}
VP = V_1 V_2
    <VP head> = <V_2 head>
    <VP head rootgloss> = <V_1 rootgloss>     | 12-APR-04 for compounding constraints
    <VP head rootgloss_V_2> <= <V_2 rootgloss> | 12-APR-04 for no Aux rule
    <VP head subject> = <V_1 head subject>
|    <V_2 head type comma> = -     | 03Apr03 CB need , at end of relcl
    <V_2 head type passive> = +
    <V_1 head type participle> = +
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
|      <V_1 head type compounded> = -         | RL 29Mar03  Need compounding for sentences like: bh^^wasvhE aw parsa Smrdh my^Swd
    <V_2 head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type no_intervening> = +   | for compounding constraint
    <V_1 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP head type participle_passive> <= +       | 12-APR-04 to restrict V+participle
    <VP rule> = 9passI

rule {VP option 9f - V final, passive}
VP = V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type passive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 9f

| object agreement restrictions not added below here for now. SHould not need since all V's marked above 05May19
| F and Fcop were identical, except for copular feature, so combined 10Dec03
rule {V option F - Aux initial, required -- Future}
V = Aux V_1 
    <V head> = <Aux head>
    <Aux head type comma> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 head infl finite> = short   | requires the verb to have the feature short_infinitive
    <Aux head infl tense future> = + | requires that the auxillary have the future feature.
    <V rootgloss> = <V_1 rootgloss>  | RL 16Jan03 pass up the root gloss so compounding works.
    <V head type> <= <V_1 head type> | type features come from V, agr from Aux
    <V head rootgloss_V_2> = <V_1 head rootgloss_V_2> | 13-APR-04 restrict Aux 
    <V head infl finite> <= +        | future adds finiteness, then can fit other rules 03Apr03 CB
    <V rule> = F

rule {V option 1 - compound with noun}
V = N V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <N head type comma> = -
    <N head type relative> = -
    <N head type reflexive> = -
    <N head type indefinite> = -
    <N head type proper> = -
    <N head infl finite> = +
    <N head case> = direct 
    <N head agr number plural> = -
    <N head type copular_suffix> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 conjoined> = -                | not conjoined V's
    <V head type compound> = + 
   {<N head type compounds_with1> = <V_1 rootgloss>
    /<N head type compounds_with2> = <V_1 rootgloss>
    /<N head type compounds_with3> = <V_1 rootgloss>
    /<N head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= +   | to prevent double compounding
    <V head type sentential> <= <N head type sentential>
    <V head type transitive> <= <N head type transitive>
    <V head type passive>    <= <N head type passive>      | let N override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <N embedded>
    <N head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 1

| rule added **19Jul06 CB
rule {V option 1dblN - double compound with noun}
V = N_1 Conj N_2 V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Conj gloss> = و
    <N_1 head type comma> = -
    <N_1 head type relative> = -
    <N_1 head type reflexive> = -
    <N_1 head type indefinite> = -
    <N_1 head type proper> = -
    <N_1 head infl finite> = +
    <N_1 head case> = direct 
    <N_1 head agr number plural> = -
    <N_1 head type copular_suffix> = -
    <N_2 head type comma> = -
    <N_2 head type relative> = -
    <N_2 head type reflexive> = -
    <N_2 head type indefinite> = -
    <N_2 head type proper> = -
    <N_2 head infl finite> = +
    <N_2 head case> = direct 
    <N_2 head agr number plural> = -
    <N_2 head type copular_suffix> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 conjoined> = -                | not conjoined V's
    <V head type compound> = + 
    {<N_1 head type compounds_with1> = <V_1 rootgloss>
    /<N_1 head type compounds_with2> = <V_1 rootgloss>
    /<N_1 head type compounds_with3> = <V_1 rootgloss>
    /<N_1 head type compounds_with4> = <V_1 rootgloss>}
    {<N_1 head type compounds_with1> = <V_1 rootgloss>
    /<N_1 head type compounds_with2> = <V_1 rootgloss>
    /<N_1 head type compounds_with3> = <V_1 rootgloss>
    /<N_1 head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= +   | to prevent double compounding
    <V head type sentential> <= <N_2 head type sentential>
    <V head type transitive> <= <N_2 head type transitive>
    <V head type passive>    <= <N_2 head type passive>      | let N override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <N_2 embedded>
    <N_1 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <N_2 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 1dblN

rule {V option 2 - compound with adjective}
V = Adj V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Adj head type comma> = -
    <Adj head type relative> = -
    <Adj head type indefinite> = -
    <Adj head type attributive> = -    | CB 23May2019 assuming like predicate adjectives
    <Adj head case> = direct 
    <Adj head type copular_suffix> = -
    {<Adj head type compounds_with1> = <V_1 rootgloss>
    /<Adj head type compounds_with2> = <V_1 rootgloss>
    /<Adj head type compounds_with3> = <V_1 rootgloss>
    /<Adj head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head type compound> = +
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= + | to prevent double compounding
    <V head type sentential> <= <Adj head type sentential>
    <V head type transitive> <= <Adj head type transitive>
    <V head type passive>    <= <Adj head type passive>      | let Adj override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <Adj embedded>
    <Adj head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 2

| rule added **19Jul06 CB
rule {V option 2dblAdj - double compound with adjective}
V = Adj_1 Conj Adj_2 V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Conj gloss> = و
    <Adj_1 head type comma> = -
    <Adj_1 head type relative> = -
    <Adj_1 head type indefinite> = -
    <Adj_1 head case> = direct
    <Adj_1 head type copular_suffix> = -
    <Adj_2 head type comma> = -
    <Adj_2 head type relative> = -
    <Adj_2 head type indefinite> = -
    <Adj_2 head case> = direct
    <Adj_2 head type copular_suffix> = -
    {<Adj_1 head type compounds_with1> = <V_1 rootgloss>
    /<Adj_1 head type compounds_with2> = <V_1 rootgloss>
    /<Adj_1 head type compounds_with3> = <V_1 rootgloss>
    /<Adj_1 head type compounds_with4> = <V_1 rootgloss>}
    {<Adj_2 head type compounds_with1> = <V_1 rootgloss>
    /<Adj_2 head type compounds_with2> = <V_1 rootgloss>
    /<Adj_2 head type compounds_with3> = <V_1 rootgloss>
    /<Adj_2 head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head type compound> = +
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= + | to prevent double compounding
    <V head type sentential> <= <Adj_2 head type sentential>
    <V head type transitive> <= <Adj_2 head type transitive>
    <V head type passive>    <= <Adj_2 head type passive>      | let Adj override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <Adj_2 embedded>
    <Adj_1 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <Adj_2 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 2dblAdj

|does this need to be changed for compound as above??  If so, check DP rules.
rule {V option 3 - compound with 'alone'}
V = Deg V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Deg head type compound> = +
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= + | to prevent double compounding
    <V rule> = 3    

|conjoined V's  added 20Oct03 CB |may need to add participle and/or other type features
|04Dec03 RL Require the verbs to be transitive. I think this is the situation that created
|the need for this rule. Acts 14:5. For the intrasitive case like Acts 13:9 compounding works
|fine with VP rule 0conj
rule {V option conjoined}
V = V_1 Conj V_2
    <V head> = <V_2 head>                 | all V's share most features
    <V head rootgloss> = <V_1 rootgloss>  | rootgloss from V_1 for compounding info
    <V head rootgloss_V_2> <= <V_2 rootgloss> | for Aux constraints 12-APR-04
    <V head infl> = <V_1 head infl>       | all V's share most features
    <V head subject> = <V_1 head subject>    
    <V_1 head type transitive> = +
    <V_2 head type transitive> = +
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head type copular> = <V_1 head type copular>
    <V head type passive> = <V_1 head type passive>
    <Conj gloss> = و
    <V conjoined> <= +       | for compounding constraint in V rule 1
    <V rule> = conjoined


|-****Coordinate DPs without recursion
rule {DP option Sand - single with 'and'}
DP = (Conj_1) DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = also
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP head case> = <DP head case_for_position>
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct       | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive
    } 
    <DP head agr number plural> <= +      | plural comes from 'and'
    <DP head agr number singular> <= -
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Sand

rule {DP option Sor - single with 'or'}
DP = (Conj_1) DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj_1 gloss> = or
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP head case> = <DP head case_for_position>
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Sor

rule {DP option Swhether - single with 'whether'}
DP = Conj_1 DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = whether
    <Conj_1 gloss> = whether
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP head case> = <DP head case_for_position>
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Swhether

|***************************
|-****Coordinate DPs, initial (with recursion)
rule {DP option Iand - initial with 'and'}
DP = (Conj_1) DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = also
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head agr number plural> <= +      | plural comes from 'and'
    <DP head agr number singular> <= -
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Iand

rule {DP option I2or - initial with two 'or'}
DP = Conj_1 DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type conjunction_gloss> = initial_ya   | to restrict splitting between subject and object
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj_1 gloss> = or
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = I2or

rule {DP option Ior - initial with 'or'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj head type conjoins_DP> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Ior

rule {DP option Iwhether - initial with 'whether'}
DP = Conj_1 DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = whether
    <Conj_1 gloss> = whether
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Iwhether

rule {DP option Icomma-or - initial with 'comma', 'or'}
DP = DP_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head type comma> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = ending  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion- comma
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive 
    } 
    <DP_2 final_conjunction gloss> = or
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Icomma-or

rule {DP option Icomma-and - initial with 'comma', 'and'}
DP = DP_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head type comma> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = ending  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion - comma
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive 
    } 
    <DP_2 final_conjunction gloss> = and
    <DP head agr number plural> <= +      | plural comes from 'and'
    <DP head agr number singular> <= -
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Icomma-and

|-****Coordinate DPs, medial only
rule {DP option Mand - medial with 'and'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -          | not initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP conjunction gloss> = <Conj gloss>  | require 'and' as upper Conj
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | non-final conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mand

rule {DP option Mor - medial with 'or'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -          | not initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP conjunction gloss> = <Conj gloss>  | require 'or' as upper Conj
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | non-final conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type coordination> <= <DP_2 head type coordination>  | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mor

rule {DP option Mwhether - medial with 'whether'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = whether
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +               | to require further recursion 
    <DP conjunction gloss> = <Conj gloss>  | require 'whether' as upper Conj
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct       | non-final conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type coordination> <= <DP_2 head type coordination>  |final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mwhether

rule {DP option Mcomma - medial with 'comma'}
DP = DP_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head type comma> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +               | to require further recursion 
    <DP conjunction gloss> = ending  | require 'comma' as upper Conj
    <DP_2 conjunction gloss> = ending  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion - comma
    <DP final_conjunction gloss> = <DP_2 final_conjunction gloss>
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct       | non-final conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type coordination> <= <DP_2 head type coordination>  |final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mcomma

|-****Coordinate DPs, final only
rule {DP option Fandor - final with 'and or'}
DP = DP_1 Conj Conj_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = or
    <Conj head type conjoins_DP> = +
    <Conj_1 head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    {<DP conjunction gloss> = and
    /<DP conjunction gloss> = or    | require 'and' or 'or' as upper Conj
    }
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fandor

rule {DP option Fandwhether - final with 'and whether'}
DP = DP_1 Conj Conj_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = whether
    <Conj head type conjoins_DP> = +
    <Conj_1 head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP conjunction gloss> = <Conj_1 gloss>  | require 'whether' as upper Conj
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct      | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fandwhether

rule {DP option Fandalso - final with 'and also'}
DP = DP_1 Conj Conj_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for Adj case info 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = also
    <Conj head type conjoins_DP> = +
    <Conj_1 head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP final_conjunction gloss> = and  | pass info for plural agreement
    <DP conjunction gloss> = ending    | require comma as upper Conj
||    <DP conjunction gloss> = <Conj gloss>  | require 'and' as upper Conj
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct       | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive 
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fandalso

rule {DP option Fand - final with 'and'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP final_conjunction gloss> = and  | pass info for plural agreement
   {<DP conjunction gloss> = ending    | require comma as upper Conj
   /<DP conjunction gloss> = and         | require 'and' as upper Conj
   }
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct       | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive 
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fand

rule {DP option For - final with 'or'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP final_conjunction gloss> = or  | pass info for non-plural agreement
    <DP conjunction gloss> = ending    | require comma as upper Conj
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_noun> <= <DP_2 head type no_head_noun> | no_head_noun from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    {<DP_1 head type modifier-final> = -
     <DP_1 head case> = direct       | initial conjuncts unmarked
    /<DP_1 head type modifier-final> = +  | unless modifier final
     <DP_1 head case> = genitive 
    } 
    {<DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    /<DP_2 head type modifier-final> = +
     <DP_2 head case> = genitive 
    } 
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = For

|-*****
rule {DP option casePst - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = +                                 
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1 head type modifier-final> = -
    <DP head case> = direct           | redo case  to = CB 23May19 
    <DP rule> = casePst

rule {DP option caseNonPstExceptDef - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = -                                 
   {<DP head type indefinite> = + 
   /<DP head type generic> = +                                 
   }                            
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1 head type modifier-final> = -
    <DP head case> = direct           | redo case to = CB 23May19 
    <DP rule> = caseNonPstExceptDef

rule {DP option caseNonPstDef - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = - 
    <DP head type indefinite> = -                                 
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = oblique  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1 head type modifier-final> = -
    <DP head case> = oblique            | redo case to = CB 23May19 
    <DP rule> = caseNonPstDef

rule {DP option caseModfinal - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1 head type modifier-final> = +   | to handle genitive case required with final modifiers
    <DP head case> = genitive              | redo case to = CB 23May19 
    <DP rule> = caseModfinal

rule {DP option caseAppos - case-marked DP including apposition}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    {
    <DP_1 head type apposition> = +    | 17Jan03  CB
    <DP_1 head type comma> = +
    /<DP_1 head type apposition> = یعنی  | 21Nov03 CB
    }
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB
    {<DP_1 head case> = direct   | changed from case from Case 17Feb03 CB
     <DP_1 head type modifier-final> = -
    /<DP_1 head case> = genitive
     <DP_1 head type modifier-final> = +
    }
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1> == ~[conjoined:+]     | apposition only, not coordination
    <DP rule> = caseAppos

| 16Jan03 RL Added this rule, moved to DP level 20Jan03 CB, split into 2 rules to avoid duplicate parses due to options in DP_2 when have PP instead 27Jan03 CB
rule {DP option Appos - Apposition, commas required} |e.g. John, the butcher, came.
DP = DP_1 DP_2
    <DP head> = <DP_1 head>           | 27Jan03CB
    <DP_1 head agr> = <DP_2 head agr>     | person and number agreement
    <DP head apposition> = <DP_2>    | pass up info for generic/refl 19Feb03 CB
    <DP_1 head type comma> = +
    <DP_2 head type comma> = +
    <DP_2 head type apposition> = -  | allow stacking only one way 20Jan03 CB
    <DP_1 head type case-marked> = -     | case-marked above apposition only 20Jan03 CB
    <DP_2 head type case-marked> = -     | case-marked above apposition only 20Jan03 CB
    <DP_1 head type relative> = -    | N cannot have REL with following modifier
    <DP_2 head type DO_contraction> = -  | DO_contraction use 1contr rule
|    <DP_2 head type coordination> = -   | not allowing coordinate apposition |removed 18Mar03 CB
    <DP head case_for_position> = <DP_1 head case_for_position> | pass down in case of iteration 27Jan03 CB
    {<DP_1 head case> = <DP head case_for_position> 
     <DP_1 head type modifier-final> = -
    /<DP_1 head case> = genitive           | except when modifier-final
     <DP_1 head type modifier-final> = +
    }
    {<DP_2 head case> = <DP head case_for_position> 
     <DP_2 head type modifier-final> = -
    /<DP_2 head case> = genitive           | except when modifier-final
     <DP_2 head type modifier-final> = +
    }
    <DP_2 head infl polarity> = +       | Apposition phrase is not negative
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP_2> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_2> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type compound> <= <DP_2 head type compound>  | 04 Apr03 CB
    <DP head type apposition> <= +    | 17Jan03 CB
    <DP rule> = Appos

| generic/ref pn cannot be checked inside PP apposition
rule {DP option PPAppos - Apposition with PP, commas required}
DP = DP_1 PP
    <DP head> = <DP_1 head>           | 27Jan03CB
    <DP_1 head type comma> = +
    <PP head type comma> = +
    <DP_1 head type case-marked> = -     | case-marked above apposition only 20Jan03 CB
    <DP_1 head type relative> = -    | N cannot have REL with following modifier
    <DP head case_for_position> = <DP_1 head case_for_position> | pass down in case of iteration 27Jan03 CB
    {<DP_1 head case> = <DP head case_for_position> 
     <DP_1 head type modifier-final> = -
    /<DP_1 head case> = genitive           | except when modifier-final
     <DP_1 head type modifier-final> = +
    }
    <PP head type sentential> = -
    <DP head reflexive> = <PP head reflexive> | pass reflexive info
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type compound> <= <PP head type compound>  | 04 Apr03 CB
    <DP head type apposition> <= +    | 17Jan03 CB
    <DP rule> = PPAppos
 
| for ygny type apposition/coordination/relativization, added 24Mar03 CB
rule {DP option ygny - "ygny"-type apposition}
DP = DP_1 Conj DP_2
    <DP head> = <DP_1 head>
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head case> = <DP_2 head case>  | assume same case marking - Ron?? 
    <Conj gloss> = یعنی
    <DP conjoined> = یعنی    | not coordination above ygny
    <DP_2 conjunction gloss> = یعنی   | to restrict interaction w/ coordination
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type apposition> <= یعنی    | 21Nov03 CB
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP rule> = یعنی
   
rule {DP option relative_clause}
DP = DP_1 CP
    <DP head> = <DP_1 head>
    <DP_1 head type comma> = -
    <DP_1 head type relative> = +
    <CP head type root> = -
    <CP head type question> = -
    <CP head type conj_suffix> = -   | 03Apr03 CB
    <CP head type relcl> = +        | 21Nov03 CB
|    <DP_1 conjoined> = -             | not conjoined head 21Apr03 CB
    <DP head type relcl> <= +
    <DP head type comma> <= <CP head type comma>
    <DP_1> == ~[conjoined:+]     | not cojoined head
    <DP rule> = relative_clause

|rule added 28Jan03 CB
rule {DP option relcl2 - relative clause with no rel suffix, head by Pron, PropN, Dem, Deg, QP, or phrases}
DP = DP_1 CP
    <DP head> = <DP_1 head>
    <DP_1 head type comma> = -
    <DP_1 head type relative> = -    | rel suffix not required
    <DP_1 head type indefinite> = -  | (but can't be indefinite instead)
    {<DP_1 conjoined> = -             | if conjoined head 
    /<DP_1 conjoined> = +             | must be mother-node
     <DP_1 mother_node> = +
    }
    {<DP_1 head type proper> = +     | for proper noun heads
    /<DP_1 head type pronoun> = +          | or pronoun heads
    /<DP_1 head type suffix_Pn> = +        | or with suffix Pn **24Jul06 CB
    /<DP_1 head type no_head_N> = +        | or Dem, Deg or QP heads
     <DP_1 head type pronoun> = -
    /<DP_1 head type no_head_N> = -       | or phrases w/ final modifiers
     <DP_1 head type pronoun> = -
     <DP_1 head type modifier-final> = +
     <DP_1 head type modifier-initial> = -
    /<DP_1 head type no_head_N> = -       | or phrases w/ initial modifiers
     <DP_1 head type pronoun> = -
     <DP_1 head type modifier-final> = -
     <DP_1 head type modifier-initial> = +
    /<DP_1 head type no_head_N> = -       | or phrases w/ modifiers both sides
     <DP_1 head type pronoun> = -
     <DP_1 head type modifier-final> = +
     <DP_1 head type modifier-initial> = +
    }
    <CP head type root> = -
    <CP head type question> = -
    <CP head type conj_suffix> = -   | 03Apr03 CB
    <CP head type relcl> = +          | 21Nov03 CB
    <DP head type case-marked> = <DP_1 head type case-marked>
    <DP head type relcl> <= +
    <DP head type comma> <= <CP head type comma>
    <DP rule> = relcl2
    
|rule added 7Apr03 CB
rule {DP option relcl2+kh - relative clause with no rel suffix, with +kh suffixed to head}
DP = DP_1 IP
    <DP head> = <DP_1 head>
    <DP_1 head type comma> = -
    <DP_1 head type comp_suffix> = +
    <IP head type root> = -
    <IP head type question> = -
    <IP head type conj_suffix> = -   | 03Apr03 CB
    <IP head type initialP> = -      | no InitP allowed in IP 21Apr03 CB
    <IP head type relcl> = +          | 21Nov03 CB
    <DP head type case-marked> = <DP_1 head type case-marked>
|    <DP_1 conjoined> = -
|    {<DP_1 conjoined> = -             | if conjoined head     ***asking Ron
|    /<DP_1 conjoined> = +             | must be mother-node
|     <DP_1 mother_node> = +
|    }
    <DP relative> = +
    <DP_1 relative> = -              | not iterative 03Jun03 CB
    <DP head type relcl> <= +
    <DP head type comma> <= <IP head type comma>
    <DP head relative conjoined> = <IP head type conjoined> | for compounding constraints with main V 20Oct03 CB
    <DP head relative compounds_with1> = <IP head type final-conjunct compounds_with1>
    <DP head relative compounds_with2> = <IP head type final-conjunct compounds_with2>
    <DP head relative compounds_with3> = <IP head type final-conjunct compounds_with3>
    <DP head relative compounds_with4> = <IP head type final-conjunct compounds_with4>
    <DP_1> == ~[conjoined:+]     | not conjoined head
    <DP rule> = relcl2+kh
    
rule {DP option 1 - no modifiers}
DP = D'
    <DP head> = <D' head>
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP rule> = 1

rule {DP option 1conjI - no modifiers, Conj initial}
DP = Conj D'
    <DP head> = <D' head>
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type comma> = -
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <DP rule> = 1conjI

rule {DP option 1conjIF - no modifiers, Conj initial, final}
DP = Conj D' Conj_2
    <DP head> = <D' head>
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <D' head type relative> = -
    <D' head type comma> = -
    <Conj head type comma> = -
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 1conjIF

rule {DP option 1conjF - no modifiers, Conj final}
DP = D' Conj
    <DP head> = <D' head>
    <D' head type comma> = -
    <D' head type relative> = -
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <Conj> == ~[gloss:یعنی]
    <DP rule> = 1conjF

rule {DP option 2a - modifiers initial}
DP = Deg_1 (Deg) D'       | Deg_1 is the negative particle "na", Deg is "alone"
    <DP head> = <D' head>
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP rule> = 2a

rule {DP option 2aconjI - modifiers initial, Conj initial}
DP = Conj Deg_1 (Deg) D'  | Deg_1 is the negative particle "na", Deg is "alone"
    <DP head> = <D' head> 
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP rule> = 2aconjI

rule {DP option 2aconjIF - modifiers initial, Conj initial, final}
DP = Conj Deg_1 (Deg) D' Conj_2   | Deg_1 is the negative "na", Deg is "alone"
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2aconjIF

rule {DP option 2aconjF - modifiers initial, Conj final}
DP = Deg_1 (Deg) D' Conj  | Deg_1 is the negative particle "na", Deg is "alone"
    <DP head> = <D' head>
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2aconjF

rule {DP option 2b - modifier initial}
DP = Deg D'
    <DP head> = <D' head>
    <Deg head type comma> = -
    {<Deg head type modifies_NP> = +
    /<Deg head type modifies_NPrep> = +  | added for drst byrwn... 10Jul03 CB
     <D' head case> = genitive 
    }
|    <Deg head agr number plural> = -   |commented off to combine rules **19Jul06 CB
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <Deg head infl polarity> = +
    <DP rule> = 2b

|Combined this rule with option 2b above since plurality does not come from Deg **19Jul06 CB
|rule {DP option 2bpl - modifier initial - plural}
|DP = Deg D'
|    <DP head> = <D' head>
|    <Deg head type comma> = -
|    <Deg head type modifies_NP> = +
|    <Deg head agr number plural> = +
|    {<Deg head case> = direct     | initial modifiers not case-marked
|     <Deg head type gen_initial> = -
|    /<Deg head case> = genitive       | unless can take genitive initially
|     <Deg head type gen_initial> = +    | 7Apr03 CB
|    }
|    <DP head type case-marked> = -
|    <DP conjoined> = -
|    <Deg head infl polarity> = +
|    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
|    <DP rule> = 2bpl

rule {DP option 2bconjI - modifier initial, Conj initial}
DP = Conj Deg D'
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = -
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Deg head infl polarity> = +
    <DP rule> = 2bconjI

rule {DP option 2bconjIpl - plural modifier initial, Conj initial}
DP = Conj Deg D'
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Deg head infl polarity> = +
    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
    <DP rule> = 2bconjIpl

rule {DP option 2bconjIF - modifier initial, Conj initial, final}
DP = Conj Deg D' Conj_2
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = -
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2bconjIF

rule {DP option 2bconjIFpl - plural modifier initial, Conj initial, final}
DP = Conj Deg D' Conj_2
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
    <DP rule> = 2bconjIFpl

rule {DP option 2bconjF - modifier initial, Conj final}
DP = Deg D' Conj
    <DP head> = <D' head>
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = -
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2bconjF

rule {DP option 2bconjFpl - plural modifier initial, Conj final}
DP = Deg D' Conj
    <DP head> = <D' head>
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
    <DP rule> = 2bconjFpl

rule {DP option 2z - modifiers final}
DP = D' Deg            
    <DP head> = <D' head>
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type comma> <= <Deg head type comma>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2z

rule {DP option 2zconjI - modifiers final, Conj initial}
DP = Conj D' Deg
    <DP head> = <D' head>
    <Conj head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <DP head type comma> <= <Deg head type comma>
    <DP head type relative> <= <Deg head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2zconjI

rule {DP option 2zconjIF - modifiers final, Conj initial, final}
DP = Conj D' Deg Conj_2
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = هم
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2zconjIF

rule {DP option 2zconjF - modifiers final, Conj final}
DP = D' Deg Conj
    <DP head> = <D' head>
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2zconjF

|-********************************************************
|rules split 29Jan03 CB to deal with phrases for relcl2
rule {D' option 4a - no modifiers}
D' = NP
    <D' head> = <NP head>
    <D' rule> = 4a

rule {D' option 4aDem - only demonstratives, initial}
D' = Dem NP
    <D' head> = <NP head>
    <Dem head type comma> = -
    <Dem head type comp_suffix> = -  | head relcl 7Apr03 CB
    <Dem head case> = direct   | Dem unmarked for case in Gilaki/Balochi when a modifier
    <D' head type wh> <= <Dem head type wh>
    <D' head infl polarity> <= <Dem head infl polarity>
    <D' head type modifier-initial> <= +  | for relcl2 constraint 29Jan03 CB
    <D' rule> = 4a

|-*********************************************************
rule {NP option 1a - no possessor}
NP = {N'' / N'}
    <NP head> = <N'' head>
    <NP head> = <N' head>
    {<NP head type genitive_suffix> = -   | if +, possessor required, eliminates NPreps
    /<NP head type genitive_suffix> = +
     <NP head type locative> = +          | 0May19 CB locatives are genitive
    }
     <NP rule> = 1a

rule {NP option 1bposs - no separate marker, possessor final}
NP = {N'' / N'} DP
    <NP head> = <N'' head>
    <NP head> = <N' head>
    <NP head type NPrep> = -        | **22Jul06 CB NPrep use 1bNPrep
    <DP head type apposition> = -   | apposition to whole DP, not just possessor 20Jan03 CB 
    <DP head type case-marked> = -           | possessor not separately case-marked 20Jan03 CB
    <DP head type no_head_N> = -    | to disallow Num, Q as possessors 14Jul03
    <N' head type comma> = -
    <N'' head type comma> = -
    <N' head type relative> = -    | N cannot have REL with following modifier
    <N'' head type relative> = -    | N cannot have REL with following modifier
    <DP head type DO_contraction> = -  | DO_contraction use 1contr rule
    <DP head type coordination> = -   | not allowing coordinate possessors  **THIS IS WHY Genitive 3 fails 22May2019 CB
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct          | changed to direct
     <DP head type pronoun> = -
     <DP head type genitive_suffix> = -
    /<DP head case> = genitive           | except for pronoun possessors
     <DP head type pronoun> = +
     <DP head type genitive_suffix> = -
    /<DP head case> = genitive           | or when has genitive_suffix
     <DP head type genitive_suffix> = +
    /<DP head case> = genitive           | or when possessor nested
     <DP head type modifier-final> = +     | this option added 12/17/02 CB
     <DP head type genitive_suffix> = -
     <DP head type pronoun> = -
    }
    <DP head infl polarity> = +       | possessors are not negative
    <DP head type relcl> = -         | no relcl within possessor 28Jan03CB
    <NP head possessor> = <DP>
    <N' head case> = genitive
    <N'' head case> = genitive
    <NP head reflexive> = <DP head reflexive> | pass reflexive info to possessor
    <NP head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <DP head> == ~[cat:Num]             | numbers can't be possessors 
    <NP head type indefinite> <= <DP head type indefinite>
    <NP head type relative> <= <DP head type relative>
    <NP head type comma> <= <DP head type comma>      | needed  17Jan03 CB
    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB
    <NP rule> = 1bposs

|rule added **22Jul06 CB to deal with differences with NPrep vs possessors, e.g. negative objects
rule {NP option 1bNPrep - NPrep object final}
NP = {N'' / N'} DP
    <NP head> = <N'' head>
    <NP head> = <N' head>
    <NP head type NPrep> = +
    <DP head type apposition> = -   | apposition to whole DP, not just object 20Jan03 CB 
    <DP head type case-marked> = -           | object not separately case-marked 20Jan03 CB
    <DP head type no_head_N> = -    | to disallow Num, Q as objects 14Jul03
    <N' head type comma> = -
    <N'' head type comma> = -
    <N' head type relative> = -    | N cannot have REL with following modifier
    <N'' head type relative> = -    | N cannot have REL with following modifier
    <DP head type DO_contraction> = -  | DO_contraction use 1contr rule
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct          | changed to direct
     <DP head type pronoun> = -
     <DP head type genitive_suffix> = -
    /<DP head case> = genitive           | except for pronoun objects
     <DP head type pronoun> = +
     <DP head type genitive_suffix> = -
    /<DP head case> = genitive           | or when has genitive_suffix
     <DP head type genitive_suffix> = +
    /<DP head case> = genitive           | or when object nested
     <DP head type modifier-final> = +     | this option added 12/17/02 CB
     <DP head type genitive_suffix> = -
     <DP head type pronoun> = -
    }
    <DP head type relcl> = -         | no relcl within object 28Jan03CB
    <NP head object> = <DP>
    <N' head case> = genitive
    <N'' head case> = genitive
    <NP head reflexive> = <DP head reflexive> | pass reflexive info to object
    <NP head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <DP head> == ~[cat:Num]             | numbers can't be objects 
    <NP head type indefinite> <= <DP head type indefinite>
    <NP head type relative> <= <DP head type relative>
    <NP head type comma> <= <DP head type comma>      | needed  17Jan03 CB
    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB
    <NP rule> = 1bNPrep

rule {NP option 1contr - no separate marker, DO_contraction possessor final}
NP = {N'' / N'} DP
    <NP head> = <N'' head>
    <NP head> = <N' head>
    <N'' head type comma> = -
    <N' head type comma> = -
    <N'' head type relative> = -    | N cannot have REL with following modifier
    <DP head type DO_contraction> = +  | DO_contraction
    <DP head case> = genitive       | specially marked for Gilaki/Balochi transfer
    <DP head infl polarity> = +       | possessors are not negative
    <DP head type relcl> = -         | no relcl within possessor 28Jan03CB
    <DP head type coordination> = -
    <NP head possessor> = <DP>
    <N' head case> = genitive
    <N'' head case> = genitive
    <N' head type DO_contraction> = -    | to eliminate double contractions
    <N'' head type DO_contraction> = -   | to eliminate double contractions
    <NP head reflexive> = <DP head reflexive> | pass reflexive info to possessor
    <NP head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <NP head type DO_contraction> <= <DP head type DO_contraction>   | for contraction form of possessor
    <NP head case> <= <DP head case>  | accusative case comes from DO_contraction
    <NP head type indefinite> <= <DP head type indefinite>
    <NP head type relative> <= <DP head type relative>
    <NP head type comma> <= <DP head type comma>
    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB
    <NP rule> = 1contr

rule {NP option 6a - non-nominal heads}
NP = {Dem / Deg / QP}
    <NP head> = <Dem head>
    <NP head> = <Deg head>
    <NP head> = <QP head>
    <QP head type human> = + | RL 11Dec02 Force an NP that consists only of a QP to be human so that we don't get two identical parses at the IP level (one for 3rd sg and one for 3rd pl subject)
    <Deg head type quantifier> = +
    <Deg head case> = direct       | RL 6Apr03 A degree word that stands alone can't have genitive suffix. This eliminates 2 extra parses from Acts 13:20a.
    <Deg head type gen_initial> = -    | RL 9May03 Likewise a degree word that takes a genitive can't stand alone.
    <Dem head type wh > = -        |- so "which" not separate
    <NP head type modifier-final> = -
    <NP head type modifier-initial> = -
    <NP head type no_head_N> = +        | to disallow compound V with neg alone
    <NP rule> = 6a

rule {NP option 6aPP - non-nominal heads, with partitive PP after}
NP = {Dem / Deg / QP} PP
    <NP head> = <Dem head>
    <NP head> = <Deg head>
    <NP head> = <QP head>
    <NP head reflexive> = <PP head reflexive> | pass reflexive info to PP
    <Dem head type comma> = -
    <Deg head type comma> = -
    <QP head type comma> = -
    <Dem head type relative> = -
    <Deg head type relative> = -
    <QP head type relative> = -
    <Deg head type quantifier> = +
    <Dem head type wh > = -        |- so "which" not separate
    <PP head type stranded> = -            |- PP must have overt complement
    <PP head type sentential> = -    |- sentential not within NP
    <NP head type modifier-final> = -
    <NP head type modifier-initial> = -
    <NP head type no_head_N> = +        | to disallow compound V with neg alone
    <NP head type relative> <= <PP head type relative>
    <NP head type comma> <= <PP head type comma>
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <PP head> == ~[rootgloss:برای]      | PP not benefactor 24Jul03 CB
    <NP rule> = 6aPP

rule {NP option 6apn - NP=Pn}
NP = Pron
    <NP head> = <Pron head>
    <NP head type reflexive> = -
    <NP rule> = 6apn

rule {NP option 6apnreflex - NP=ReflexivePn}
NP = Pron
    <NP head> = <Pron head>
    <NP head type reflexive> = +
    <Pron head agr> = <NP head reflexive head agr> |enforce agreement
    <NP rule> = 6apnreflex

|-********************************************************
rule {N'' option 1 - QPs initial}
N'' = QP N'
    <N'' head> = <N' head>
    <QP head type comma> = -
    <QP head case> = direct    | initial modifiers unmarked for case
    <N'' head agr number> <= <QP head agr number>
    <N'' head type indefinite> <= <QP head type indefinite> | to make nouns preceded by one to pass indefinite feature up.
    <N' head type modifier-initial> <= +  | for relcl2 constraint 28Jan03 CB
    <N'' rule> = 1

rule {N'' option 2 - QPs final}
N'' = N' QP
    <N'' head> = <N' head>
    <QP head agr number> = <N' head agr number>
    <N' head type comma> = -
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N'' head case> = genitive
    <QP head case> = direct   
|    <QP head type ordinal> = +
    <N'' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type relative> <= <QP head type relative>
    <N'' head type comma> <= <QP head type comma>
    <N'' head type compound> <= -  | 04Apr03 CB
    <N'' rule> = 2

|-********************************************************
rule {N' option 1a - AdjP initial, recursive}
N' = AdjP N'_2
    <N' head> = <N'_2 head>
    <AdjP head case> = direct   | initial modifiers unmarked for case
    <AdjP head type DP-initial> = +
    <AdjP head type attributive> = + | 8May19 RL CB here as well as AdjP final true?
|    <AdjP head type ordinal> = -     | testing this with genitive.txt
    <AdjP head type comma> = -
    <N' head type modifier-initial> <= +  | for relcl2 constraint 28Jan03 CB
    <N' rule> = 1a

rule {N' option 1b - AdjP final, recursive}
N' = N'_2 AdjP
    <N' head> = <N'_2 head>
    <AdjP head type DP-final> = +
    <AdjP head type attributive> = + | 8May19 RL
    <N'_2 head type comma> = -   
|    <N' head case> <= genitive        | 2019 changed to <=  ***BUT this doesn't stop oblique suffix on N***
    <N' head case> = genitive        | 2019 changed to <=  ***BUT this doesn't stop oblique suffix on N so testing = again***
    <N' head type nonfinalcoordination> = -  | coordination use next rule
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type genitive_suffix> <= <AdjP head type genitive_suffix> | N marking can be overridden by AdjP, if AdjP also marked then another modifier required.
    {<AdjP head case> = <N' head case_for_position> | case from DP position
     <AdjP head type genitive_suffix> = -
    /<AdjP head type genitive_suffix> = + | unless has genitive_suffix
     <AdjP head case> = genitive
    }
    <N' head type indefinite> <= <AdjP head type indefinite>
    <N' head type relative> <= <AdjP head type relative>
    <N' head type comma> <= <AdjP head type comma>
    <N' head type compound> <= <AdjP head type compound>  | 04Apr03 CB
    <N' rule> = 1b


rule {N' option 1bcoord - AdjP final, recursive, for non-final coordination}
N' = N'_2 AdjP
    <N' head> = <N'_2 head>
    <AdjP head type DP-final> = +
    <AdjP head type attributive> = + | 8May19 RL
    <N'_2 head type comma> = -
|    <N' head case> <= genitive        | 2019 changed to <=  ***BUT this doesn't stop oblique suffix on N***
    <N' head case> = genitive        | 2019 changed to <=  ***BUT this doesn't stop oblique suffix on N so testing = again***
    <N' head type nonfinalcoordination> = +
    <N' head type coordination> = +
    {<AdjP head case> = direct             | unmarked for case 14Aug03 CB
     <AdjP head type genitive_suffix> = -
    /<AdjP head type genitive_suffix> = +        | unless has genitive_suffix
     <AdjP head case> = genitive
    }
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type genitive_suffix> <= <AdjP head type genitive_suffix> | N marking can be overridden by AdjP, if AdjP also marked then another modifier required.
    <N' head type indefinite> <= <AdjP head type indefinite>
    <N' head type relative> <= <AdjP head type relative>
    <N' head type comma> <= <AdjP head type comma>
    <N' head type compound> <= <AdjP head type compound>  | 04Apr03 CB
    <N' rule> = 1bcoord

|09-APR-04 added for participle - need to noload any Adj entries derived from V+participle **20Jul06 CB Not restricting this type of participle so constraint removed.
rule {N' option 2b - VPart final, recursive}
N' = N'_2 V
    <N' head> = <N'_2 head>
    <N'_2 head type comma> = -
    <N'_2 head case> = genitive
    <N' head type nonfinalcoordination> = -  | coordination use next rule
    <V head type participle> = +
    {<N' head case_for_position> = <V head case>   | case from DP position
     <V head type genitive_suffix> = -
    /<V head type genitive_suffix> = +        | unless has genitive_suffix
     <V head case> = genitive
    }
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type genitive_suffix> <= <V head type genitive_suffix> | N marking can be overridden by V, if V also marked then another modifier required.
    <N' head type indefinite> <= -
    <N' head type relative> <= -
    <N' head type comma> <= <V head type comma>
    <N' head type compound> <= - 
    <V> == ~[rootgloss:شدن]         | Sdn does not form participle adjectives 13-APR-04
    <N' rule> = 2b

|09-APR-04 added for participle **20Jul06 CB Not restricting this type of participle so constraint removed.
rule {N' option 2bcoord - VPart final, recursive, for non-final coordination}
N' = N'_2 V
    <N' head> = <N'_2 head>
    <N'_2 head type comma> = -
    <N'_2 head case> = genitive
    <N' head type nonfinalcoordination> = +
    <N' head type coordination> = +
    <V head type participle> = +
    {<V head case> = direct             | unmarked for case 14Aug03 CB
     <V head type genitive_suffix> = -
    /<V head type genitive_suffix> = +        | unless has genitive_suffix
     <V head case> = genitive
    }
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type genitive_suffix> <= <V head type genitive_suffix> | N marking can be overridden by V, if V also marked then another modifier required.
    <N' head type indefinite> <= -
    <N' head type relative> <= -
    <N' head type comma> <= <V head type comma>
    <N' head type compound> <= - 
    <V> == ~[rootgloss:شدن]         | Sdn does not form participle adjectives 13-APR-04
    <N' rule> = 2bcoord

| try eliminating this rule, seldom needed 19Feb03
|rule {N' option 3bPP - noun, PP final}
|N' = N PP
|    <N' head> = <N head>
|    <N' head rootgloss> = <N rootgloss>  |for compounding constraint 10Jul03
|    <PP head type stranded> = -         |- P must have overt complement
|    <PP head type sentential> = -       |- sentential not within NP
|    <N head type comma> = -
|    <N' head type no_head_N> = -
|    <N' head reflexive> = <PP head reflexive> | pass reflexive info to PP
|    <N' head type relative> = -    | N cannot have REL with following modifier
|    <N' head type relative> <= <PP head type relative>
|    <N' head type comma> <= <PP head type comma>
|    <N' head type compound> <= <PP head type compound>  | 17Jan03 CB
|    <N' rule> = 3bPP
    
rule {N' option 3b - noun}
N' = N
    <N' head> = <N head>
    <N' head rootgloss> = <N rootgloss>  |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <N' head subject head agr> = none         | testing 28May19 ***
    <N' head type attributive> = -       | testing 28May19 ***
    <N' head type no_head_N> = -
    <N' rule> = 3b

rule {N' option conj - conjoined nouns}
N' =  (N_3 Conj_2) N_2 Conj_1 N_1
    <N' head> = <N_1 head>
    <N' head rootgloss> = <N_2 rootgloss>  |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <N_2 head case> = direct
    <N_3 head case> = direct
    <Conj_2 gloss> = و
    <Conj_1 gloss> = و
    <N' conjoined> = +   | to prevent recursion
    <N_1 conjoined> = -
    <N_2 conjoined> = -
    <N_3 conjoined> = -
    <N' head type no_head_N> = -
    <N' head type genitive_suffix> <= +   | to force following modifier
    <N' rule> = conj

|added 09Jul03 CB for compound infinitives
rule {N' option compound}
N' = N_1 N
    <N' head> = <N head>
    <N' head rootgloss> = <N rootgloss>   |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <N_1 head case> = direct
    <N_1 head type comma> = -
    <N_1 head type compound> = +
    <N head infl finite> = -
    <N' head type no_head_N> = -
   {<N_1 head type compounds_with1> = <N rootgloss>
   /<N_1 head type compounds_with2> = <N rootgloss>
   /<N_1 head type compounds_with3> = <N rootgloss>
   /<N_1 head type compounds_with4> = <N rootgloss>}
    <N' rule> = compound

|added 11Dec03 CB for compound infinitives with Adj
rule {N' option compoundAdj}
N' = Adj N
    <N' head> = <N head>
    <N' head rootgloss> = <N rootgloss>   |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <Adj head case> = direct
    <Adj head type comma> = -
    <Adj head type compound> = +
    <N head infl finite> = -
    <N' head type no_head_N> = -
   {<Adj head type compounds_with1> = <N rootgloss>
   /<Adj head type compounds_with2> = <N rootgloss>
   /<Adj head type compounds_with3> = <N rootgloss>
   /<Adj head type compounds_with4> = <N rootgloss>}
    <N' rule> = compoundAdj

|-***********************************************************
rule {PP option 2a - optional adverbial or Deg before}
PP = (Deg_1) (AdvP / Deg) P'
    <PP head> = <P' head>
    <Deg_1 head type comma> = -
    <AdvP head type comma> = -
    <Deg head type comma> = -
    <AdvP head type manner> = +
    <Deg head type modifies_PP> = +
    <Deg_1 head type modifies_PP> = +
    <Deg_1 head infl polarity> = -
    {<P' head case> = direct         |new
     <P' head type genitive_suffix> = -
    /<P' head case> = genitive
     <P' head type genitive_suffix> = + 
    /<P' head case> = genitive
     <P' head type genitive_suffix> = -
     <P' head type prefix_Prep> = +    | added 17Feb03 CB for P AdjP
     <P' head type modifier-final> = + | added 17Feb03 CB for P AdjP
    } 
    <PP rule> = 2a

|-****test postpositions**2019*****************************************************
|not sure when valid, so eliminating for now
|rule {P' option 1aPost - postpositions, DP complement only}
|P' = DP P
|    <P' head> = <P head>
|    <P' head rootgloss> = <P rootgloss>
|    <P head type comma> = -
|    <P head type PP-final> = +
|    <P' head reflexive> = <DP head reflexive> | pass reflexive info
|    <DP head type case-marked> = -            |RL 30Jan02  can't have a DO marker in a postpositional phrase.
|    <P' head type stranded> = -  |- not missing a complement
|    <P' head object> = <DP>         |- for passive, logical constraint 27Jan03 CB
|    <P' head type wh> <= <DP head type wh> |- wh for pied-piping
|    <P' rule> = 1aPost

|-***********************************************************
rule {P' option 1a - prepositions, DP complement only - not for bray, bh not pronoun object}
P' = P (N) DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type comma> = -
    <N head type comma> = -
    <N head subject head agr> = none         | testing 28May19 ***
    <N head type attributive> = -       | testing 28May19 ***
    <P head type PP-initial> = +
    {<P head type prefix_Prep> = - 
    /<P head type prefix_Prep> = +  
     <P head type demonstrative> = + | need to allow object with bdyn qrar CB
     <P head type pronoun> = -       | but not with pronoun
    }
    <P head type suffix_Pn> = -
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <DP head type case-marked> = -                    |RL 30Jan02  can't have a DO marker in a prepositional phrase.
    <DP head type DO_contraction> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct   | ??? we are setting the case of the DP in the Prep Phrase to direct (this should help with transfer to Gil. Balochi?)
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    /<DP head case> = oblique	
    /<DP head type NPrep> = +	|**| 24Jul06 CB removed for NPreps
    }
    <P' head type stranded> = -  |- not missing a complement
    <P' head object> = <DP>         |- for passive, logical constraint 27Jan03 CB
    <N head case> = oblique
    <P head case> = direct
    <DP head participle> = none                                      | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P> == ~[rootgloss:برای]      | benefactors use option benefactorPP
    <P' head type comma> <= <DP head type comma>
    <P' head type wh> <= <DP head type wh> |- wh for pied-piping
|following removed 21Apr03 CB for "from this same man" marked on P.  If this doesn't work for other situations, need to split feature between source and locative, mark source on P, and add InitP rule allowing source PPs.
|    <P' head type locative> <= <DP head type locative> | Feb03 CB
    <P' head> == [rootgloss:به] -> ~[object:[head:[type:[pronoun:+]]]]  |only nonpronominals with bh (otherwise use next rule) 27Jan03 CB
    <P' rule> = 1a

| this rule split off 27Jan03 CB
rule {P' option 1abhpn - prepositions, pronoun complement only with bh}
P' = P (N) DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <DP head type case-marked> = -                    |RL 30Jan02  can't have a DO marker in a prepositional phrase.
    <DP head type DO_contraction> = -
|    <DP head type coordination> = -   | no coordinate DP objects for this rule Feb03 CB**7/17/06
    <DP head type nonfinalcoordination> = -
    <DP head case> = oblique   | ????we are setting the case of the pronoun after bh to oblique (this should help with transfer to Gil.) Balochi?
    <DP head type pronoun> = +      | pronoun objects only for this rule
    <P rootgloss> = به           | P = bh only for this rule
    <P' head type stranded> = -  |- not missing a complement
    <P' head object> = <DP>         |- for passive, etc.
    <N head case> = genitive
    <P head case> = direct   |??
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P' head type comma> <= <DP head type comma>
    <P' head type wh> <= <DP head type wh> |- wh for pied-piping
    <P' head type locative> <= <DP head type locative> | Feb03 CB
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete**7/17/06
    <P' rule> = 1abhpn

rule {P' option benefactorPP - prepositions, DP complement only for bray}
P' = P DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P rootgloss> = برای
    <P head type comma> = -
    <P head type PP-initial> = +
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <DP head type case-marked> = -                    |RL 30Jan02  can't have a DO marker in a prepositional phrase.
    <DP head type DO_contraction> = -
    <DP head case_for_position> = benefactor  | to know normal case for conjoined DPs
    {<DP head case> = benefactor   | we are setting the case of the DP in the Prep Phrase after bray to benefactor (this should help with transfer to Gil.)Balochi?
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <P' head type stranded> = -  |- not missing a complement
    <P' head object> = <DP>         |- for passive, etc.
    <P' head type wh> = <DP head type wh> |- wh for pied-piping
    <P' head type locative> = -         | not locative InitP  20Feb03 CB
    <P head case> = direct
    <DP head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P' head type comma> <= <DP head type comma> 
    <P' rule> = benefactorPP

rule {P' option 1adv - prepositions, locative complement only}
P' = P (N) AdvP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <AdvP head type locative> = +
    <P' head type locative> = +  | pass up locative feature
    <P' head type stranded> = -  |- not missing a complement
    <N head case> = oblique
    <P head case> = direct
    <P' head type comma> <= <AdvP head type comma> 
    <P> == ~[rootgloss:برای]      | benefactors use option benefactorPP
    <P' rule> = 1adv

| RL added this rule 23Jan03 E.g: bh^^vwr kaml
rule {P' option 1adj - prepositions, adjective}
P' = P AdjP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <AdjP head case> = direct   
    <P' head type stranded> = -  |- not missing a complement
    <P head case> = genitive        | added 17Feb03 CB
    <P head type prefix_Prep> = +     | added 17Feb03 CB
    <P head type modifier-final> <= + | added 17Feb03 CB
    <P' head type comma> <= <AdjP head type comma> 
    <P> == ~[rootgloss:برای]      | benefactors use option benefactorPP
    <P' rule> = 1adj

|| CB added this rule 3Mar03 E.g: az mucir |was supposed to be az mcr 'from Egypt'
|rule {P' option 1adj2 - prepositions, adjective}
|P' = P AdjP
|    <P' head> = <P head>
|    <P' head rootgloss> = <P rootgloss>
|    <P head type comma> = -
|    <N head type comma> = -
|    <P head type PP-initial> = +
|    <AdjP head case> = direct   
|    <P' head type stranded> = -  |- not missing a complement
|    <P head case> = direct
|    <P head type prefix_Prep> = -     | distinguish from 1adj
|    <P' head type comma> <= <AdjP head type comma> 
|    <P' rule> = 1adj2

rule {P' option 2a - prepositions, IP complement }
P' = P (N) IP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <P head type prefix_Prep> = -
    <P head type suffix_Pn> = -
    <P' head type root> = <IP head type root>
    <IP head type question> = -
    <IP head infl mood imperative> = -
    <IP head type participle> = -   | restrict participle within IP
    <IP head type copular> = -
    <IP head type initialP> = -     | restrict InitP within IP complement 
    <IP head type conj_suffix> = -  | not h2 13Mar03 CB per Ron
    <P' head type stranded> = -  |- not missing a complement
    <P' head type sentential> = +
    <N head case> = oblique
    <P head case> = direct
    <P' head type comma> <= <IP head type comma> 
    <P> == ~[rootgloss:برای]      | benefactors use option benefactorPP
    <IP head type relcl> = -        | not a rel clause 21Nov03 CB
    <P' rule> = 2a

rule {P' option bh-I - prefixed to oblique, complement required}
P' = P DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type comma> = -
    <P head type passive> = +
    <P head case> = oblique
    <P head type prefix_Prep> = +
    <P head type suffix_Pn> = -
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <P' head object> = <DP>         |- for passive, etc.
    <DP head type DO_contraction> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    {<DP head case> = direct
     <DP head type modifier-final> = -
    /<DP head type modifier-final> = +   | to handle genitive case required with final modifiers
     <DP head case> = genitive
    }
    <P' head type stranded> = -         |- not missing a complement
    <DP head participle> = none                                      | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P' head type comma> <= <DP head type comma> 
    <P' rule> = bh-I

rule {P' option bh-II - prefixed to N, Pn or Dem complement so full PP}
P' = P
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type passive> = +
    {<P head case> = direct
     <P head type genitive_suffix> = -   |new
    /<P head type genitive_suffix> = +
     <P head case> = genitive 
    }
    <P head type prefix_Prep> = +
    <P' head type stranded> = -         |- not missing a complement
    <P' rule> = bh-II

|added 15Jul03 CB
rule {P' option pn-sf - pronoun suffixed to P so full PP}
P' = P
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P head type passive> = -
    {<P head case> = direct
     <P head type genitive_suffix> = -   |new
    /<P head type genitive_suffix> = +
     <P head case> = genitive
    }
    <P head type suffix_Pn> = +
    <P' head type stranded> = -         |- not missing a complement
    <P' rule> = pn-sf

|-***********************************************************
rule {QP option 2 as Numbers - modifiers final}
QP = NumP (Q) (Adj)
    <QP head> = <NumP head>
    <Adj head type ordinal> = +
    <Adj head case> = <QP head case>
    <QP rule> = 2

rule {QP option Q alone}
QP = Q
    <QP head> = <Q head>
    <QP rule> = Q

rule {NumP option number (optional classifier)}
NumP = Num (NumCl)
    <NumP head> = <Num head>
    <NumCl head case> = <NumP head case>
    <NumP rule> = number

| RL 5Feb02 classifier alone.
rule {NumCl option numberCl}
NumP = NumCl
    <NumP head> = <NumCl head>
    <NumP rule> = numberCl

rule {NumP as compound}
NumP = NumP_1 Conj NumP_2
    <NumP head> = <NumP_1 head>
    <NumP conjoined> = +                             |RL 5Feb02 limit recursion to right node only.
    <NumP_1 conjoined> = -
    <NumP rule> = compound 

|-***********************************************************
rule {AdjP option 0 - conjoined }
AdjP = AdjP_1 Conj AdjP_2
    <AdjP head> = <AdjP_2 head>   | make right-headed for case marking 03Apr03
    <AdjP conjoined> = +          | limit recursion to left node only
    <AdjP_2 conjoined> = -
    <AdjP_1 head case> = direct  | unmarked except final
    <Conj head type conjoins_DP> = +
    <AdjP_1 head type relative> = -  | intial conjunct not marked with REL
    <AdjP rule> = 0

rule {AdjP option 2 - degree modifiers initial }
AdjP = (Deg) Adj
    <AdjP head> = <Adj head>
    <Deg head type comma> = -
    <Deg head type modifies_Adj> = +
    <AdjP head infl polarity> <= <Deg head infl polarity>
    <AdjP rule> = 2

|-***********************************************************
rule {AdvP option 2 - modifiers initial}
AdvP = (Deg) Adv
    <AdvP head> = <Adv head>
    <Deg head type comma> = -
    <Deg head type modifies_Adv> = <Adv head type>
    <AdvP rule> = 2

